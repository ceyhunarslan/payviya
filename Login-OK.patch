tag Login-OK
Tagger: Ceyhun <ege.ceyhunarslan@gmail.com>
Date:   Sun Apr 20 19:29:06 2025 +0300

Stable version with working login functionality

commit 51a1cf453db0527f39b29a4cc7115b55c7e19bed
Author: Ceyhun <ege.ceyhunarslan@gmail.com>
Date:   Sun Apr 20 19:29:00 2025 +0300

    Stable version: Login functionality working properly

diff --git a/alembic.ini b/alembic.ini
new file mode 100644
index 0000000..e8435c5
--- /dev/null
+++ b/alembic.ini
@@ -0,0 +1,102 @@
+# A generic, single database configuration.
+
+[alembic]
+# path to migration scripts
+script_location = migrations
+
+# template used to generate migration files
+# file_template = %%(rev)s_%%(slug)s
+
+# sys.path path, will be prepended to sys.path if present.
+# defaults to the current working directory.
+prepend_sys_path = .
+
+# timezone to use when rendering the date within the migration file
+# as well as the filename.
+# If specified, requires the python-dateutil library that can be
+# installed by adding `alembic[tz]` to the pip requirements
+# string value is passed to dateutil.tz.gettz()
+# leave blank for localtime
+# timezone =
+
+# max length of characters to apply to the
+# "slug" field
+# truncate_slug_length = 40
+
+# set to 'true' to run the environment during
+# the 'revision' command, regardless of autogenerate
+# revision_environment = false
+
+# set to 'true' to allow .pyc and .pyo files without
+# a source .py file to be detected as revisions in the
+# versions/ directory
+# sourceless = false
+
+# version location specification; This defaults
+# to migrations/versions.  When using multiple version
+# directories, initial revisions must be specified with --version-path.
+# The path separator used here should be the separator specified by "version_path_separator" below.
+# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions
+
+# version path separator; As mentioned above, this is the character used to split
+# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
+# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
+# Valid values for version_path_separator are:
+#
+# version_path_separator = :
+# version_path_separator = ;
+# version_path_separator = space
+version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.
+
+# the output encoding used when revision files
+# are written from script.py.mako
+# output_encoding = utf-8
+
+sqlalchemy.url = postgresql://postgres:postgres@localhost:5432/payviya
+
+
+[post_write_hooks]
+# post_write_hooks defines scripts or Python functions that are run
+# on newly generated revision scripts.  See the documentation for further
+# detail and examples
+
+# format using "black" - use the console_scripts runner, against the "black" entrypoint
+# hooks = black
+# black.type = console_scripts
+# black.entrypoint = black
+# black.options = -l 79 REVISION_SCRIPT_FILENAME
+
+# Logging configuration
+[loggers]
+keys = root,sqlalchemy,alembic
+
+[handlers]
+keys = console
+
+[formatters]
+keys = generic
+
+[logger_root]
+level = WARN
+handlers = console
+qualname =
+
+[logger_sqlalchemy]
+level = WARN
+handlers =
+qualname = sqlalchemy.engine
+
+[logger_alembic]
+level = INFO
+handlers =
+qualname = alembic
+
+[handler_console]
+class = StreamHandler
+args = (sys.stderr,)
+level = NOTSET
+formatter = generic
+
+[formatter_generic]
+format = %(levelname)-5.5s [%(name)s] %(message)s
+datefmt = %H:%M:%S 
\ No newline at end of file
diff --git a/api/main.py b/api/main.py
index 57dc095..93b835b 100644
--- a/api/main.py
+++ b/api/main.py
@@ -10,9 +10,9 @@ from apscheduler.schedulers.background import BackgroundScheduler
 sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 
 # Now use absolute imports
-from app.api.v1.router import api_router
-from app.core.config import settings
-from app.tasks.campaign_sync_task import schedule_campaign_sync
+from api.api.v1.router import api_router
+from api.core.config import settings
+from api.tasks.campaign_sync_task import schedule_campaign_sync
 
 # Configure logging
 logging.basicConfig(
diff --git a/app/__init__.py b/app/__init__.py
new file mode 100644
index 0000000..314a843
--- /dev/null
+++ b/app/__init__.py
@@ -0,0 +1,2 @@
+# PayViya - Payment Assistant API
+# Main application package 
\ No newline at end of file
diff --git a/app/api/__init__.py b/app/api/__init__.py
new file mode 100644
index 0000000..f9048ff
--- /dev/null
+++ b/app/api/__init__.py
@@ -0,0 +1 @@
+# API module initialization 
\ No newline at end of file
diff --git a/app/api/deps.py b/app/api/deps.py
new file mode 100644
index 0000000..1ebbf3a
--- /dev/null
+++ b/app/api/deps.py
@@ -0,0 +1,20 @@
+from fastapi import Depends, HTTPException, status
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.models.user import User
+
+
+def get_current_admin_user(db: Session = Depends(get_db)):
+    """
+    Simple dependency to get an admin user for testing purposes.
+    In a real application, this would verify JWT tokens, etc.
+    """
+    # For demo purposes, just return a mock admin user
+    # In a real app, this would verify authentication
+    return {
+        "id": 1,
+        "email": "admin@payviya.com",
+        "is_admin": True,
+        "full_name": "Admin User"
+    } 
\ No newline at end of file
diff --git a/app/api/v1/__init__.py b/app/api/v1/__init__.py
new file mode 100644
index 0000000..ce122a5
--- /dev/null
+++ b/app/api/v1/__init__.py
@@ -0,0 +1 @@
+# API v1 module initialization 
\ No newline at end of file
diff --git a/app/api/v1/deps.py b/app/api/v1/deps.py
new file mode 100644
index 0000000..1ebbf3a
--- /dev/null
+++ b/app/api/v1/deps.py
@@ -0,0 +1,20 @@
+from fastapi import Depends, HTTPException, status
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.models.user import User
+
+
+def get_current_admin_user(db: Session = Depends(get_db)):
+    """
+    Simple dependency to get an admin user for testing purposes.
+    In a real application, this would verify JWT tokens, etc.
+    """
+    # For demo purposes, just return a mock admin user
+    # In a real app, this would verify authentication
+    return {
+        "id": 1,
+        "email": "admin@payviya.com",
+        "is_admin": True,
+        "full_name": "Admin User"
+    } 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/__init__.py b/app/api/v1/endpoints/__init__.py
new file mode 100644
index 0000000..a16935d
--- /dev/null
+++ b/app/api/v1/endpoints/__init__.py
@@ -0,0 +1 @@
+# Endpoints module initialization 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/admin.py b/app/api/v1/endpoints/admin.py
new file mode 100644
index 0000000..f359e70
--- /dev/null
+++ b/app/api/v1/endpoints/admin.py
@@ -0,0 +1,214 @@
+from typing import Any, List, Dict, Optional
+from fastapi import APIRouter, Depends, HTTPException, Path, Query
+from sqlalchemy.orm import Session
+from sqlalchemy import func, desc, and_, extract, cast, Date
+from datetime import datetime, timedelta
+
+from app.db.base import get_db
+from app.models.campaign import Campaign, Bank, CreditCard, Merchant
+from app.models.user import Recommendation, RecommendationClick
+from app.schemas.campaign import BankCreate, BankInDB, CreditCardCreate, CreditCardInDB, MerchantCreate, MerchantInDB
+
+from app.api.v1.endpoints import admin_campaigns
+from app.api.v1.endpoints.admin_analytics import router as analytics_router
+
+router = APIRouter()
+
+# Include the admin campaigns router
+router.include_router(
+    admin_campaigns.router, 
+    prefix="/campaigns", 
+    tags=["admin-campaigns"]
+)
+
+# Include the analytics router
+router.include_router(
+    analytics_router, 
+    prefix="/analytics", 
+    tags=["admin-analytics"]
+)
+
+# Bank endpoints
+@router.get("/banks", response_model=List[BankInDB])
+def get_banks(
+    skip: int = 0, 
+    limit: int = 100,
+    db: Session = Depends(get_db)
+):
+    """
+    Get all banks.
+    """
+    banks = db.query(Bank).offset(skip).limit(limit).all()
+    return banks
+
+@router.post("/banks", response_model=BankInDB)
+def create_bank(
+    bank: BankCreate,
+    db: Session = Depends(get_db)
+):
+    """
+    Create a new bank.
+    """
+    db_bank = Bank(**bank.dict())
+    db.add(db_bank)
+    db.commit()
+    db.refresh(db_bank)
+    return db_bank
+
+# Credit Card endpoints
+@router.get("/credit-cards", response_model=List[CreditCardInDB])
+def get_credit_cards(
+    skip: int = 0, 
+    limit: int = 100,
+    db: Session = Depends(get_db)
+):
+    """
+    Get all credit cards.
+    """
+    credit_cards = db.query(CreditCard).offset(skip).limit(limit).all()
+    return credit_cards
+
+@router.post("/credit-cards", response_model=CreditCardInDB)
+def create_credit_card(
+    credit_card: CreditCardCreate,
+    db: Session = Depends(get_db)
+):
+    """
+    Create a new credit card.
+    """
+    db_credit_card = CreditCard(**credit_card.dict())
+    db.add(db_credit_card)
+    db.commit()
+    db.refresh(db_credit_card)
+    return db_credit_card
+
+# Merchant endpoints
+@router.get("/merchants", response_model=List[MerchantInDB])
+def get_merchants(
+    skip: int = 0, 
+    limit: int = 100,
+    db: Session = Depends(get_db)
+):
+    """
+    Get all merchants.
+    """
+    merchants = db.query(Merchant).offset(skip).limit(limit).all()
+    return merchants
+
+@router.post("/merchants", response_model=MerchantInDB)
+def create_merchant(
+    merchant: MerchantCreate,
+    db: Session = Depends(get_db)
+):
+    """
+    Create a new merchant.
+    """
+    db_merchant = Merchant(**merchant.dict())
+    db.add(db_merchant)
+    db.commit()
+    db.refresh(db_merchant)
+    return db_merchant
+
+# Analytics endpoints
+@router.get("/analytics/recommendations")
+def get_recommendation_stats(
+    *,
+    db: Session = Depends(get_db),
+    days: int = 30,
+) -> Dict[str, Any]:
+    """
+    Get recommendation statistics for the dashboard.
+    """
+    # Calculate date range
+    end_date = datetime.now()
+    start_date = end_date - timedelta(days=days)
+    
+    # Total recommendations in period
+    total_recommendations = db.query(func.count(Recommendation.id)).filter(
+        Recommendation.created_at >= start_date,
+        Recommendation.created_at <= end_date
+    ).scalar()
+    
+    # Total clicks in period
+    total_clicks = db.query(func.count(RecommendationClick.id)).filter(
+        RecommendationClick.created_at >= start_date,
+        RecommendationClick.created_at <= end_date
+    ).scalar()
+    
+    # Clicks by action type
+    clicks_by_type = db.query(
+        RecommendationClick.action_type,
+        func.count(RecommendationClick.id).label('count')
+    ).filter(
+        RecommendationClick.created_at >= start_date,
+        RecommendationClick.created_at <= end_date
+    ).group_by(RecommendationClick.action_type).all()
+    
+    clicks_by_type_dict = {action_type: count for action_type, count in clicks_by_type}
+    
+    # Calculate conversion rate
+    conversion_rate = 0
+    if total_recommendations > 0:
+        conversion_rate = (total_clicks / total_recommendations) * 100
+    
+    return {
+        "period_days": days,
+        "total_recommendations": total_recommendations,
+        "total_clicks": total_clicks,
+        "conversion_rate": round(conversion_rate, 2),
+        "clicks_by_type": clicks_by_type_dict
+    }
+
+@router.get("/analytics/campaigns")
+def get_campaign_stats(
+    *,
+    db: Session = Depends(get_db),
+    days: int = 30,
+) -> Dict[str, Any]:
+    """
+    Get campaign performance statistics.
+    """
+    # Calculate date range
+    end_date = datetime.now()
+    start_date = end_date - timedelta(days=days)
+    
+    # Get recommendations by campaign
+    campaign_stats = db.query(
+        Recommendation.campaign_id,
+        func.count(Recommendation.id).label('impression_count'),
+        func.count(RecommendationClick.id).label('click_count')
+    ).outerjoin(
+        RecommendationClick,
+        Recommendation.id == RecommendationClick.recommendation_id
+    ).filter(
+        Recommendation.created_at >= start_date,
+        Recommendation.created_at <= end_date
+    ).group_by(Recommendation.campaign_id).all()
+    
+    # Enrich with campaign details
+    campaign_details = []
+    for campaign_id, impression_count, click_count in campaign_stats:
+        campaign = db.query(Campaign).filter(Campaign.id == campaign_id).first()
+        if campaign:
+            ctr = 0
+            if impression_count > 0:
+                ctr = (click_count / impression_count) * 100
+                
+            campaign_details.append({
+                "campaign_id": campaign_id,
+                "campaign_name": campaign.name,
+                "bank_name": campaign.bank.name if campaign.bank else "Unknown",
+                "card_name": campaign.credit_card.name if campaign.credit_card else "Unknown",
+                "impression_count": impression_count,
+                "click_count": click_count,
+                "ctr": round(ctr, 2)
+            })
+    
+    # Sort by impression count descending
+    campaign_details.sort(key=lambda x: x["impression_count"], reverse=True)
+    
+    return {
+        "period_days": days,
+        "campaign_count": len(campaign_details),
+        "campaigns": campaign_details
+    } 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/admin_analytics.py b/app/api/v1/endpoints/admin_analytics.py
new file mode 100644
index 0000000..ddaa46c
--- /dev/null
+++ b/app/api/v1/endpoints/admin_analytics.py
@@ -0,0 +1,59 @@
+from typing import Any, List, Dict
+from fastapi import APIRouter, Depends, HTTPException
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.api.deps import get_current_admin_user
+
+router = APIRouter()
+
+@router.get("/dashboard")
+def get_dashboard_analytics(
+    *,
+    current_admin = Depends(get_current_admin_user),
+) -> Any:
+    """
+    Get dashboard analytics for admin.
+    """
+    # In a real app, this would fetch data from a database
+    return {
+        "campaigns_active": 32,
+        "campaigns_pending": 5,
+        "users_total": 1250,
+        "cards_registered": 3210,
+        "recent_activity": [
+            {"type": "campaign_created", "timestamp": "2023-04-15T10:30:00Z"},
+            {"type": "user_registered", "timestamp": "2023-04-15T09:45:00Z"},
+            {"type": "card_added", "timestamp": "2023-04-15T08:30:00Z"}
+        ]
+    }
+
+@router.get("/campaign-stats")
+def get_campaign_stats(
+    *,
+    current_admin = Depends(get_current_admin_user),
+) -> Any:
+    """
+    Get campaign statistics for admin.
+    """
+    # In a real app, this would fetch and aggregate data from a database
+    return {
+        "by_category": {
+            "dining": 15,
+            "shopping": 22,
+            "travel": 8,
+            "entertainment": 12
+        },
+        "by_bank": {
+            "Garanti BBVA": 18,
+            "Yapı Kredi": 14,
+            "İş Bankası": 12,
+            "Akbank": 10,
+            "Others": 5
+        },
+        "by_status": {
+            "active": 32,
+            "pending": 5,
+            "expired": 24
+        }
+    } 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/admin_campaigns.py b/app/api/v1/endpoints/admin_campaigns.py
new file mode 100644
index 0000000..a36865f
--- /dev/null
+++ b/app/api/v1/endpoints/admin_campaigns.py
@@ -0,0 +1,108 @@
+from typing import List, Optional
+from fastapi import APIRouter, Depends, HTTPException, Query, Path, Body
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.models.campaign import Campaign, CampaignStatus, CampaignSource
+from app.services.campaign_sync_service import CampaignSyncService
+from app.schemas.campaign import (
+    CampaignCreate, 
+    CampaignUpdate, 
+    CampaignImportResponse,
+    PendingCampaignRead,
+    CampaignApproval
+)
+from app.api.deps import get_current_admin_user
+
+router = APIRouter()
+
+@router.get("/pending", response_model=List[PendingCampaignRead])
+async def get_pending_campaigns(
+    skip: int = 0,
+    limit: int = 100,
+    db: Session = Depends(get_db),
+    current_user = Depends(get_current_admin_user)
+):
+    """
+    Get campaigns that are pending approval
+    """
+    campaign_sync_service = CampaignSyncService(db)
+    pending_campaigns = campaign_sync_service.get_pending_campaigns(skip=skip, limit=limit)
+    return pending_campaigns
+
+@router.post("/approve/{campaign_id}", response_model=CampaignApproval)
+async def approve_campaign(
+    campaign_id: int = Path(..., description="The ID of the campaign to approve"),
+    notes: Optional[str] = Body(None, description="Review notes"),
+    db: Session = Depends(get_db),
+    current_user = Depends(get_current_admin_user)
+):
+    """
+    Approve a campaign that is pending approval
+    """
+    campaign_sync_service = CampaignSyncService(db)
+    result = campaign_sync_service.approve_campaign(
+        campaign_id=campaign_id,
+        admin_id=current_user.id,
+        review_notes=notes
+    )
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result
+
+@router.post("/reject/{campaign_id}", response_model=CampaignApproval)
+async def reject_campaign(
+    campaign_id: int = Path(..., description="The ID of the campaign to reject"),
+    notes: str = Body(..., description="Reason for rejection"),
+    db: Session = Depends(get_db),
+    current_user = Depends(get_current_admin_user)
+):
+    """
+    Reject a campaign that is pending approval
+    """
+    campaign_sync_service = CampaignSyncService(db)
+    result = campaign_sync_service.reject_campaign(
+        campaign_id=campaign_id,
+        admin_id=current_user.id,
+        review_notes=notes
+    )
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result
+
+@router.post("/sync-banks", response_model=CampaignImportResponse)
+async def sync_campaigns_now(
+    db: Session = Depends(get_db),
+    current_user = Depends(get_current_admin_user)
+):
+    """
+    Manually trigger the campaign sync process for all banks
+    """
+    campaign_sync_service = CampaignSyncService(db)
+    result = await campaign_sync_service.sync_all_banks()
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result
+
+@router.post("/sync-bank/{bank_id}", response_model=CampaignImportResponse)
+async def sync_bank_campaigns(
+    bank_id: int = Path(..., description="The ID of the bank to sync campaigns from"),
+    db: Session = Depends(get_db),
+    current_user = Depends(get_current_admin_user)
+):
+    """
+    Manually trigger the campaign sync process for a specific bank
+    """
+    campaign_sync_service = CampaignSyncService(db)
+    result = await campaign_sync_service.sync_bank_campaigns(bank_id)
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/auth.py b/app/api/v1/endpoints/auth.py
new file mode 100644
index 0000000..c2066e3
--- /dev/null
+++ b/app/api/v1/endpoints/auth.py
@@ -0,0 +1,72 @@
+from datetime import timedelta
+from typing import Any
+
+from fastapi import APIRouter, Depends, HTTPException
+from fastapi.security import OAuth2PasswordRequestForm
+from sqlalchemy.orm import Session
+
+from app import schemas
+from app.api.v1 import deps
+from app.core import security
+from app.core.config import settings
+from app.models.user import User
+from app.utils.password import get_password_hash, verify_password
+
+router = APIRouter()
+
+
+@router.post("/register", response_model=schemas.User)
+def register_user(
+    user_in: schemas.UserCreate,
+    db: Session = Depends(deps.get_db),
+) -> Any:
+    """
+    Register a new user.
+    """
+    # Check if user with this email exists
+    user = db.query(User).filter(User.email == user_in.email).first()
+    if user:
+        raise HTTPException(
+            status_code=400,
+            detail="User with this email already exists.",
+        )
+    
+    # Create new user
+    user_data = user_in.dict(exclude={"password"})
+    user_data["hashed_password"] = get_password_hash(user_in.password)
+    
+    db_user = User(**user_data)
+    db.add(db_user)
+    db.commit()
+    db.refresh(db_user)
+    
+    return db_user
+
+
+@router.post("/login/access-token", response_model=schemas.Token)
+def login_access_token(
+    db: Session = Depends(deps.get_db),
+    form_data: OAuth2PasswordRequestForm = Depends(),
+) -> Any:
+    """
+    OAuth2 compatible token login, get an access token for future requests.
+    """
+    user = db.query(User).filter(User.email == form_data.username).first()
+    if not user or not verify_password(form_data.password, user.hashed_password):
+        raise HTTPException(
+            status_code=401,
+            detail="Incorrect email or password",
+        )
+    elif not user.is_active:
+        raise HTTPException(
+            status_code=400,
+            detail="Inactive user",
+        )
+    
+    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
+    return {
+        "access_token": security.create_access_token(
+            user.id, expires_delta=access_token_expires
+        ),
+        "token_type": "bearer",
+    } 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/banks.py b/app/api/v1/endpoints/banks.py
new file mode 100644
index 0000000..74a2d59
--- /dev/null
+++ b/app/api/v1/endpoints/banks.py
@@ -0,0 +1,63 @@
+from typing import Any, Dict
+from fastapi import APIRouter, Depends, HTTPException, Body
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.services.bank_service import BankService
+
+router = APIRouter()
+
+
+@router.post("/campaigns/{campaign_id}/enroll")
+async def enroll_in_campaign(
+    campaign_id: int,
+    user_identifiers: Dict[str, Any] = Body(...),
+    db: Session = Depends(get_db)
+) -> Dict[str, Any]:
+    """
+    Enroll a user in a specific bank campaign.
+    
+    This endpoint calls the corresponding bank's API to enroll the user in the
+    campaign, which may be required to activate certain card benefits or promotions.
+    
+    The user_identifiers field should contain the data required by the bank for
+    identification, which may include:
+    - masked_card_number: The last 4 digits of a card
+    - customer_id: Bank's customer ID
+    - phone_number: User's registered phone number
+    - other bank-specific identifiers
+    """
+    bank_service = BankService(db)
+    result = await bank_service.enroll_in_campaign(
+        campaign_id=campaign_id,
+        user_identifiers=user_identifiers
+    )
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result
+
+
+@router.get("/campaigns/{campaign_id}/enrollments/{enrollment_id}")
+async def check_enrollment_status(
+    campaign_id: int,
+    enrollment_id: str,
+    db: Session = Depends(get_db)
+) -> Dict[str, Any]:
+    """
+    Check the status of a previous campaign enrollment.
+    
+    This endpoint allows checking whether a previous enrollment request
+    was successful or is still being processed.
+    """
+    bank_service = BankService(db)
+    result = await bank_service.check_enrollment_status(
+        campaign_id=campaign_id,
+        enrollment_id=enrollment_id
+    )
+    
+    if not result["success"]:
+        raise HTTPException(status_code=400, detail=result["message"])
+    
+    return result 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/campaigns.py b/app/api/v1/endpoints/campaigns.py
new file mode 100644
index 0000000..e133f40
--- /dev/null
+++ b/app/api/v1/endpoints/campaigns.py
@@ -0,0 +1,145 @@
+from typing import Any, List, Optional
+from fastapi import APIRouter, Depends, HTTPException, Query, Path
+from sqlalchemy.orm import Session
+from datetime import datetime
+
+from app.db.base import get_db
+from app.models.campaign import Campaign, Bank, CreditCard, Merchant, CategoryEnum
+from app.schemas.campaign import (
+    CampaignCreate,
+    CampaignUpdate,
+    CampaignInDB,
+    CampaignWithRelations
+)
+
+router = APIRouter()
+
+
+@router.get("/", response_model=List[CampaignInDB])
+def list_campaigns(
+    *,
+    db: Session = Depends(get_db),
+    bank_id: Optional[int] = None,
+    card_id: Optional[int] = None,
+    category: Optional[CategoryEnum] = None,
+    is_active: Optional[bool] = True,
+    skip: int = 0,
+    limit: int = 100,
+) -> Any:
+    """
+    Retrieve campaigns with optional filtering.
+    """
+    query = db.query(Campaign)
+    
+    if bank_id is not None:
+        query = query.filter(Campaign.bank_id == bank_id)
+    if card_id is not None:
+        query = query.filter(Campaign.card_id == card_id)
+    if category is not None:
+        query = query.filter(Campaign.category == category)
+    if is_active is not None:
+        query = query.filter(Campaign.is_active == is_active)
+    
+    # Only get current or future campaigns
+    now = datetime.now()
+    query = query.filter(Campaign.end_date >= now)
+    
+    # Order by newest first
+    query = query.order_by(Campaign.created_at.desc())
+    
+    campaigns = query.offset(skip).limit(limit).all()
+    return campaigns
+
+
+@router.get("/{campaign_id}", response_model=CampaignWithRelations)
+def get_campaign(
+    *,
+    db: Session = Depends(get_db),
+    campaign_id: int = Path(..., gt=0),
+) -> Any:
+    """
+    Get detailed information about a specific campaign.
+    """
+    campaign = db.query(Campaign).filter(Campaign.id == campaign_id).first()
+    if not campaign:
+        raise HTTPException(status_code=404, detail="Campaign not found")
+    return campaign
+
+
+@router.post("/", response_model=CampaignInDB)
+def create_campaign(
+    *,
+    db: Session = Depends(get_db),
+    campaign_in: CampaignCreate,
+) -> Any:
+    """
+    Create a new campaign.
+    """
+    # Verify bank exists
+    bank = db.query(Bank).filter(Bank.id == campaign_in.bank_id).first()
+    if not bank:
+        raise HTTPException(status_code=404, detail="Bank not found")
+    
+    # Verify card exists
+    card = db.query(CreditCard).filter(CreditCard.id == campaign_in.card_id).first()
+    if not card:
+        raise HTTPException(status_code=404, detail="Credit card not found")
+    
+    # Verify merchant exists if provided
+    if campaign_in.merchant_id:
+        merchant = db.query(Merchant).filter(Merchant.id == campaign_in.merchant_id).first()
+        if not merchant:
+            raise HTTPException(status_code=404, detail="Merchant not found")
+    
+    # Create campaign
+    campaign = Campaign(**campaign_in.dict())
+    db.add(campaign)
+    db.commit()
+    db.refresh(campaign)
+    return campaign
+
+
+@router.put("/{campaign_id}", response_model=CampaignInDB)
+def update_campaign(
+    *,
+    db: Session = Depends(get_db),
+    campaign_id: int = Path(..., gt=0),
+    campaign_in: CampaignUpdate,
+) -> Any:
+    """
+    Update a campaign.
+    """
+    campaign = db.query(Campaign).filter(Campaign.id == campaign_id).first()
+    if not campaign:
+        raise HTTPException(status_code=404, detail="Campaign not found")
+    
+    # Update campaign with non-null fields from input
+    update_data = campaign_in.dict(exclude_unset=True)
+    for field, value in update_data.items():
+        setattr(campaign, field, value)
+    
+    db.commit()
+    db.refresh(campaign)
+    return campaign
+
+
+@router.delete("/{campaign_id}")
+def delete_campaign(
+    *,
+    db: Session = Depends(get_db),
+    campaign_id: int = Path(..., gt=0),
+) -> Any:
+    """
+    Delete a campaign.
+    
+    Note: This only soft-deletes by setting is_active to False.
+    """
+    campaign = db.query(Campaign).filter(Campaign.id == campaign_id).first()
+    if not campaign:
+        raise HTTPException(status_code=404, detail="Campaign not found")
+    
+    # Soft delete
+    campaign.is_active = False
+    db.commit()
+    
+    return {"success": True, "message": "Campaign deactivated successfully"} 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/mock_bank_api.py b/app/api/v1/endpoints/mock_bank_api.py
new file mode 100644
index 0000000..7963cab
--- /dev/null
+++ b/app/api/v1/endpoints/mock_bank_api.py
@@ -0,0 +1,36 @@
+from fastapi import APIRouter, Body
+from typing import Dict, Any
+import uuid
+
+# Create a router for the mock bank API
+router = APIRouter()
+
+@router.post("/campaigns/enroll")
+async def mock_enroll_in_campaign(data: Dict[str, Any] = Body(...)) -> Dict[str, Any]:
+    """
+    Mock endpoint for bank campaign enrollment
+    This simulates what a real bank API would return when enrolling in a campaign
+    """
+    # Generate a unique enrollment ID
+    enrollment_id = str(uuid.uuid4())
+    
+    return {
+        "success": True,
+        "message": "Enrollment successful",
+        "enrollment_id": enrollment_id,
+        "status": "approved",
+        "expiry": "2025-12-31T23:59:59"
+    }
+
+@router.get("/campaigns/enrollments/{enrollment_id}")
+async def mock_check_enrollment_status(enrollment_id: str) -> Dict[str, Any]:
+    """
+    Mock endpoint for checking campaign enrollment status
+    This simulates what a real bank API would return when checking enrollment status
+    """
+    return {
+        "success": True,
+        "status": "approved",
+        "message": "Enrollment is active",
+        "expiry": "2025-12-31T23:59:59"
+    } 
\ No newline at end of file
diff --git a/app/api/v1/endpoints/recommendations.py b/app/api/v1/endpoints/recommendations.py
new file mode 100644
index 0000000..530333f
--- /dev/null
+++ b/app/api/v1/endpoints/recommendations.py
@@ -0,0 +1,58 @@
+from typing import Any, List, Dict
+from fastapi import APIRouter, Depends, HTTPException, Query
+from sqlalchemy.orm import Session
+
+from app.db.base import get_db
+from app.schemas.recommendation import (
+    RecommendationRequest, 
+    RecommendationResponse,
+    RecommendationClickRequest,
+    RecommendationClickResponse
+)
+from app.services.recommendation_service import RecommendationService
+
+router = APIRouter()
+
+
+@router.post("/", response_model=RecommendationResponse)
+def get_card_recommendations(
+    *,
+    request: RecommendationRequest,
+    db: Session = Depends(get_db)
+) -> Any:
+    """
+    Get card recommendations based on cart amount, category, and user cards.
+    
+    This endpoint will analyze the transaction details and return:
+    - Recommendations for cards the user already has
+    - Recommendations for new cards they could apply for
+    """
+    recommendation_service = RecommendationService(db)
+    return recommendation_service.get_recommendations(request)
+
+
+@router.post("/click", response_model=RecommendationClickResponse)
+def track_recommendation_click(
+    *,
+    request: RecommendationClickRequest,
+    db: Session = Depends(get_db)
+) -> Any:
+    """
+    Track when a user clicks on a recommendation (apply, enroll or select).
+    
+    This is used for analytics and to provide redirect URLs for card applications 
+    or enrollment in bank promotions.
+    """
+    recommendation_service = RecommendationService(db)
+    result = recommendation_service.track_recommendation_click(
+        recommendation_id=request.recommendation_id,
+        user_id=request.user_id,
+        session_id=request.session_id,
+        action_type=request.action_type
+    )
+    
+    return RecommendationClickResponse(
+        success=result["success"],
+        redirect_url=result.get("redirect_url"),
+        message=result["message"]
+    ) 
\ No newline at end of file
diff --git a/app/api/v1/router.py b/app/api/v1/router.py
new file mode 100644
index 0000000..828ab9b
--- /dev/null
+++ b/app/api/v1/router.py
@@ -0,0 +1,12 @@
+from fastapi import APIRouter
+
+from app.api.v1.endpoints import campaigns, recommendations, banks, admin, mock_bank_api, auth
+
+api_router = APIRouter()
+
+api_router.include_router(campaigns.router, prefix="/campaigns", tags=["campaigns"])
+api_router.include_router(recommendations.router, prefix="/recommendations", tags=["recommendations"])
+api_router.include_router(banks.router, prefix="/banks", tags=["banks"])
+api_router.include_router(admin.router, prefix="/admin", tags=["admin"])
+api_router.include_router(mock_bank_api.router, prefix="/mock-api", tags=["mock-api"])
+api_router.include_router(auth.router, prefix="/auth", tags=["auth"]) 
\ No newline at end of file
diff --git a/app/core/__init__.py b/app/core/__init__.py
new file mode 100644
index 0000000..b2d745b
--- /dev/null
+++ b/app/core/__init__.py
@@ -0,0 +1,7 @@
+# Core module initialization
+# To start developing, you can:
+# 1. Create a `.env` file based on the `.env.example` template
+# 2. Start the application with Docker Compose:
+#    ```
+#    docker-compose up -d
+#    ```
\ No newline at end of file
diff --git a/app/core/config.py b/app/core/config.py
new file mode 100644
index 0000000..d7932b0
--- /dev/null
+++ b/app/core/config.py
@@ -0,0 +1,42 @@
+import secrets
+from typing import List, Optional, Dict, Any
+
+from pydantic import PostgresDsn, validator
+from pydantic_settings import BaseSettings
+
+
+class Settings(BaseSettings):
+    API_V1_STR: str = "/api/v1"
+    SECRET_KEY: str = secrets.token_urlsafe(32)
+    ACCESS_TOKEN_EXPIRE_MINUTES: int = 10080  # 7 days
+    
+    # CORS
+    CORS_ORIGINS: List[str] = ["*"]  # Allow all origins for development
+    
+    # Database
+    POSTGRES_SERVER: str = "localhost"
+    POSTGRES_USER: str = "postgres"
+    POSTGRES_PASSWORD: str = "postgres"
+    POSTGRES_DB: str = "payviya"
+    POSTGRES_PORT: int = 5432
+    SQLALCHEMY_DATABASE_URI: Optional[PostgresDsn] = None
+
+    @validator("SQLALCHEMY_DATABASE_URI", pre=True)
+    def assemble_db_connection(cls, v: Optional[str], values: Dict[str, Any]) -> Any:
+        if isinstance(v, str):
+            return v
+        return PostgresDsn.build(
+            scheme="postgresql",
+            username=values.get("POSTGRES_USER"),
+            password=values.get("POSTGRES_PASSWORD"),
+            host=values.get("POSTGRES_SERVER"),
+            port=values.get("POSTGRES_PORT"),
+            path=f"{values.get('POSTGRES_DB') or ''}",
+        )
+
+    class Config:
+        case_sensitive = True
+        env_file = ".env"
+
+
+settings = Settings() 
\ No newline at end of file
diff --git a/app/core/security.py b/app/core/security.py
new file mode 100644
index 0000000..3a8bce8
--- /dev/null
+++ b/app/core/security.py
@@ -0,0 +1,33 @@
+from datetime import datetime, timedelta
+from typing import Any, Optional
+
+import jwt
+from passlib.context import CryptContext
+
+from app.core.config import settings
+
+pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
+
+ALGORITHM = "HS256"
+
+
+def create_access_token(
+    subject: Any, expires_delta: Optional[timedelta] = None
+) -> str:
+    if expires_delta:
+        expire = datetime.utcnow() + expires_delta
+    else:
+        expire = datetime.utcnow() + timedelta(
+            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
+        )
+    to_encode = {"exp": expire, "sub": str(subject)}
+    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
+    return encoded_jwt
+
+
+def verify_password(plain_password: str, hashed_password: str) -> bool:
+    return pwd_context.verify(plain_password, hashed_password)
+
+
+def get_password_hash(password: str) -> str:
+    return pwd_context.hash(password) 
\ No newline at end of file
diff --git a/app/db/base.py b/app/db/base.py
new file mode 100644
index 0000000..8544401
--- /dev/null
+++ b/app/db/base.py
@@ -0,0 +1,18 @@
+from sqlalchemy import create_engine
+from sqlalchemy.ext.declarative import declarative_base
+from sqlalchemy.orm import sessionmaker
+
+from app.core.config import settings
+
+engine = create_engine(str(settings.SQLALCHEMY_DATABASE_URI), pool_pre_ping=True)
+SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+
+Base = declarative_base()
+
+# Dependency to get DB session
+def get_db():
+    db = SessionLocal()
+    try:
+        yield db
+    finally:
+        db.close() 
\ No newline at end of file
diff --git a/app/main.py b/app/main.py
new file mode 100644
index 0000000..9dc3896
--- /dev/null
+++ b/app/main.py
@@ -0,0 +1,86 @@
+import logging
+import sys
+import os
+import uvicorn
+from fastapi import FastAPI
+from fastapi.middleware.cors import CORSMiddleware
+from apscheduler.schedulers.background import BackgroundScheduler
+
+# Make sure the app is in the Python path
+current_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+if current_dir not in sys.path:
+    sys.path.insert(0, current_dir)
+
+# Import app modules using absolute imports
+from app.api.v1.router import api_router
+from app.core.config import settings
+from app.tasks.campaign_sync_task import schedule_campaign_sync
+
+# Configure logging
+logging.basicConfig(
+    level=logging.INFO,
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
+)
+logger = logging.getLogger(__name__)
+
+app = FastAPI(
+    title="PayViya API",
+    description="Payment assistant API for card recommendations and campaign participation",
+    version="0.1.0",
+    openapi_url=f"{settings.API_V1_STR}/openapi.json",
+    docs_url="/docs",
+    redoc_url="/redoc",
+)
+
+# Set up CORS - Allow all origins for development
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],  # Allow all origins
+    allow_credentials=True,
+    allow_methods=["*"],  # Allow all methods
+    allow_headers=["*"],  # Allow all headers
+)
+
+# Include API routes
+app.include_router(api_router, prefix="/api/v1")
+
+# Set up APScheduler for background tasks
+scheduler = BackgroundScheduler()
+
+@app.on_event("startup")
+async def startup_event():
+    """Initialize services on startup"""
+    logger.info("Starting application...")
+    
+    # Schedule campaign sync tasks
+    schedule_campaign_sync(scheduler)
+    
+    # Start the scheduler
+    scheduler.start()
+    
+    logger.info("Application startup complete")
+
+@app.on_event("shutdown")
+async def shutdown_event():
+    """Clean up on shutdown"""
+    logger.info("Shutting down application...")
+    
+    # Shut down the scheduler
+    if scheduler.running:
+        scheduler.shutdown()
+    
+    logger.info("Application shutdown complete")
+
+# Root endpoint
+@app.get("/")
+async def root():
+    return {
+        "message": "Welcome to PayViya API - Payment Assistant and Card Recommendation Service",
+        "docs": "/docs"
+    }
+
+if __name__ == "__main__":
+    # Print current working directory and sys.path to help with debugging
+    print(f"Current directory: {os.getcwd()}")
+    print(f"Python path: {sys.path}")
+    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True) 
\ No newline at end of file
diff --git a/app/models/__init__.py b/app/models/__init__.py
new file mode 100644
index 0000000..7ea36ac
--- /dev/null
+++ b/app/models/__init__.py
@@ -0,0 +1,8 @@
+# Models module initialization
+
+# Import Base
+from app.db.base import Base
+
+# Import all models to make them available when importing from app.models
+from app.models.campaign import Campaign, Bank, CreditCard, Merchant, CategoryEnum, DiscountType
+from app.models.user import User, Recommendation, RecommendationClick 
\ No newline at end of file
diff --git a/app/models/campaign.py b/app/models/campaign.py
new file mode 100644
index 0000000..fde576c
--- /dev/null
+++ b/app/models/campaign.py
@@ -0,0 +1,138 @@
+from sqlalchemy import Column, Integer, String, Float, Boolean, Text, ForeignKey, DateTime, Enum
+from sqlalchemy.orm import relationship
+from sqlalchemy.sql import func
+import enum
+
+from app.db.base import Base
+
+
+class CategoryEnum(str, enum.Enum):
+    ELECTRONICS = "electronics"
+    FASHION = "fashion"
+    GROCERY = "grocery"
+    TRAVEL = "travel"
+    RESTAURANT = "restaurant"
+    FUEL = "fuel"
+    ENTERTAINMENT = "entertainment"
+    OTHER = "other"
+
+
+class DiscountType(str, enum.Enum):
+    PERCENTAGE = "percentage"
+    CASHBACK = "cashback"
+    POINTS = "points"
+    INSTALLMENT = "installment"
+
+
+class CampaignSource(str, enum.Enum):
+    MANUAL = "manual"           # Created manually in admin panel
+    BANK_API = "bank_api"       # Imported from bank API
+    FINTECH_API = "fintech_api" # Imported from fintech partners
+    PARTNER_API = "partner_api" # Imported from other partners
+
+
+class CampaignStatus(str, enum.Enum):
+    DRAFT = "draft"             # Newly created, not yet approved
+    PENDING = "pending"         # Pending approval (for imported campaigns)
+    APPROVED = "approved"       # Approved and active
+    REJECTED = "rejected"       # Rejected by admin
+    ARCHIVED = "archived"       # No longer active but kept for reference
+
+
+class Campaign(Base):
+    __tablename__ = "campaigns"
+
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(255), nullable=False)
+    description = Column(Text)
+    bank_id = Column(Integer, ForeignKey("banks.id"))
+    card_id = Column(Integer, ForeignKey("credit_cards.id"))
+    category = Column(Enum(CategoryEnum), nullable=False)
+    discount_type = Column(Enum(DiscountType), nullable=False)
+    discount_value = Column(Float, nullable=False)
+    min_amount = Column(Float, default=0)
+    max_discount = Column(Float, nullable=True)
+    start_date = Column(DateTime, nullable=False)
+    end_date = Column(DateTime, nullable=False)
+    merchant_id = Column(Integer, ForeignKey("merchants.id"), nullable=True)
+    is_active = Column(Boolean, default=True)
+    requires_enrollment = Column(Boolean, default=False)
+    enrollment_url = Column(String(512), nullable=True)
+    
+    # New fields for hybrid approach
+    source = Column(Enum(CampaignSource), default=CampaignSource.MANUAL, nullable=False)
+    status = Column(Enum(CampaignStatus), default=CampaignStatus.APPROVED, nullable=False)
+    external_id = Column(String(255), nullable=True)  # ID in the external system
+    priority = Column(Integer, default=0)  # Higher number = higher priority
+    last_sync_at = Column(DateTime(timezone=True), nullable=True)  # When was it last synced
+    review_notes = Column(Text, nullable=True)  # Admin notes on approval/rejection
+    reviewed_by = Column(Integer, ForeignKey("users.id"), nullable=True)  # Who reviewed it
+    
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+
+    # Relationships
+    bank = relationship("Bank", back_populates="campaigns")
+    credit_card = relationship("CreditCard", back_populates="campaigns")
+    merchant = relationship("Merchant", back_populates="campaigns")
+    reviewer = relationship("User", foreign_keys=[reviewed_by])
+
+
+class Bank(Base):
+    __tablename__ = "banks"
+
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(255), nullable=False)
+    logo_url = Column(String(512))
+    api_base_url = Column(String(512), nullable=True)
+    api_key = Column(String(255), nullable=True)
+    api_secret = Column(String(255), nullable=True)
+    
+    # New fields for campaign sync
+    campaign_sync_enabled = Column(Boolean, default=False)
+    campaign_sync_endpoint = Column(String(512), nullable=True)
+    last_campaign_sync_at = Column(DateTime(timezone=True), nullable=True)
+    auto_approve_campaigns = Column(Boolean, default=False)  # Whether to auto-approve from this bank
+    
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+
+    # Relationships
+    campaigns = relationship("Campaign", back_populates="bank")
+    credit_cards = relationship("CreditCard", back_populates="bank")
+
+
+class CreditCard(Base):
+    __tablename__ = "credit_cards"
+
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(255), nullable=False)
+    bank_id = Column(Integer, ForeignKey("banks.id"))
+    card_type = Column(String(50), nullable=False)  # e.g., Visa, Mastercard
+    card_tier = Column(String(50), nullable=False)  # e.g., Gold, Platinum
+    annual_fee = Column(Float, nullable=True)
+    rewards_rate = Column(Float, nullable=True)
+    application_url = Column(String(512))
+    affiliate_code = Column(String(100), nullable=True)
+    logo_url = Column(String(512))
+    is_active = Column(Boolean, default=True)
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+
+    # Relationships
+    bank = relationship("Bank", back_populates="credit_cards")
+    campaigns = relationship("Campaign", back_populates="credit_card")
+
+
+class Merchant(Base):
+    __tablename__ = "merchants"
+
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(255), nullable=False)
+    categories = Column(String(255), nullable=False)  # Comma-separated categories
+    logo_url = Column(String(512))
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+
+    # Relationships
+    campaigns = relationship("Campaign", back_populates="merchant") 
\ No newline at end of file
diff --git a/app/models/user.py b/app/models/user.py
new file mode 100644
index 0000000..d2cab9e
--- /dev/null
+++ b/app/models/user.py
@@ -0,0 +1,67 @@
+from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Table, Text, Float
+from sqlalchemy.orm import relationship
+from sqlalchemy.sql import func
+
+from app.db.base import Base
+
+
+# Association table for user_credit_cards
+user_credit_cards = Table(
+    "user_credit_cards",
+    Base.metadata,
+    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True),
+    Column("credit_card_id", Integer, ForeignKey("credit_cards.id"), primary_key=True),
+)
+
+
+class User(Base):
+    __tablename__ = "users"
+
+    id = Column(Integer, primary_key=True, index=True)
+    email = Column(String(255), unique=True, index=True, nullable=True)
+    hashed_password = Column(String(255), nullable=True)
+    is_active = Column(Boolean, default=True)
+    is_superuser = Column(Boolean, default=False)
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+
+    # Relationships
+    credit_cards = relationship("CreditCard", secondary=user_credit_cards)
+    recommendations = relationship("Recommendation", back_populates="user")
+    recommendation_clicks = relationship("RecommendationClick", back_populates="user")
+
+
+class Recommendation(Base):
+    __tablename__ = "recommendations"
+
+    id = Column(Integer, primary_key=True, index=True)
+    user_id = Column(Integer, ForeignKey("users.id"))
+    session_id = Column(String(255), nullable=True)  # For anonymous users
+    campaign_id = Column(Integer, ForeignKey("campaigns.id"))
+    merchant_name = Column(String(255), nullable=True)
+    cart_amount = Column(Float, nullable=False)
+    cart_category = Column(String(100), nullable=True)
+    discount_amount = Column(Float, nullable=False)
+    original_amount = Column(Float, nullable=False)
+    is_existing_card = Column(Boolean, default=True)
+    needs_enrollment = Column(Boolean, default=False)
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+
+    # Relationships
+    user = relationship("User", back_populates="recommendations")
+    campaign = relationship("Campaign")
+
+
+class RecommendationClick(Base):
+    __tablename__ = "recommendation_clicks"
+
+    id = Column(Integer, primary_key=True, index=True)
+    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
+    session_id = Column(String(255), nullable=True)  # For anonymous users
+    recommendation_id = Column(Integer, ForeignKey("recommendations.id"))
+    action_type = Column(String(50), nullable=False)  # card_apply, enroll, select
+    created_at = Column(DateTime(timezone=True), server_default=func.now())
+
+    # Relationships
+    user = relationship("User", back_populates="recommendation_clicks")
+    recommendation = relationship("Recommendation") 
\ No newline at end of file
diff --git a/app/schemas/__init__.py b/app/schemas/__init__.py
new file mode 100644
index 0000000..91e9516
--- /dev/null
+++ b/app/schemas/__init__.py
@@ -0,0 +1 @@
+# Schemas module initialization 
\ No newline at end of file
diff --git a/app/schemas/campaign.py b/app/schemas/campaign.py
new file mode 100644
index 0000000..f247f2b
--- /dev/null
+++ b/app/schemas/campaign.py
@@ -0,0 +1,217 @@
+from datetime import datetime
+from typing import Optional, List, Dict, Any
+from pydantic import BaseModel, Field, HttpUrl
+
+from app.models.campaign import CategoryEnum, DiscountType, CampaignSource, CampaignStatus
+
+
+# Bank schemas
+class BankBase(BaseModel):
+    name: str
+    logo_url: Optional[HttpUrl] = None
+
+
+class BankCreate(BankBase):
+    api_base_url: Optional[str] = None
+    api_key: Optional[str] = None
+    api_secret: Optional[str] = None
+
+
+class BankUpdate(BankBase):
+    name: Optional[str] = None
+    api_base_url: Optional[str] = None
+    api_key: Optional[str] = None
+    api_secret: Optional[str] = None
+
+
+class BankInDB(BankBase):
+    id: int
+    created_at: datetime
+    updated_at: Optional[datetime] = None
+
+    class Config:
+        orm_mode = True
+
+
+# Credit Card schemas
+class CreditCardBase(BaseModel):
+    name: str
+    bank_id: int
+    card_type: str
+    card_tier: str
+    annual_fee: Optional[float] = None
+    rewards_rate: Optional[float] = None
+    application_url: HttpUrl
+    affiliate_code: Optional[str] = None
+    logo_url: Optional[HttpUrl] = None
+    is_active: bool = True
+
+
+class CreditCardCreate(CreditCardBase):
+    pass
+
+
+class CreditCardUpdate(CreditCardBase):
+    name: Optional[str] = None
+    bank_id: Optional[int] = None
+    card_type: Optional[str] = None
+    card_tier: Optional[str] = None
+    application_url: Optional[HttpUrl] = None
+    logo_url: Optional[HttpUrl] = None
+    is_active: Optional[bool] = None
+
+
+class CreditCardInDB(CreditCardBase):
+    id: int
+    created_at: datetime
+    updated_at: Optional[datetime] = None
+
+    class Config:
+        orm_mode = True
+
+
+# Merchant schemas
+class MerchantBase(BaseModel):
+    name: str
+    categories: str
+    logo_url: Optional[HttpUrl] = None
+
+
+class MerchantCreate(MerchantBase):
+    pass
+
+
+class MerchantUpdate(MerchantBase):
+    name: Optional[str] = None
+    categories: Optional[str] = None
+    logo_url: Optional[HttpUrl] = None
+
+
+class MerchantInDB(MerchantBase):
+    id: int
+    created_at: datetime
+    updated_at: Optional[datetime] = None
+
+    class Config:
+        orm_mode = True
+
+
+# Base schema
+class CampaignBase(BaseModel):
+    name: str
+    description: Optional[str] = None
+    bank_id: int
+    card_id: int
+    category: CategoryEnum
+    discount_type: DiscountType
+    discount_value: float = Field(..., gt=0)
+    min_amount: Optional[float] = 0
+    max_discount: Optional[float] = None
+    start_date: datetime
+    end_date: datetime
+    merchant_id: Optional[int] = None
+    is_active: bool = True
+    requires_enrollment: bool = False
+    enrollment_url: Optional[str] = None
+
+
+# Schema for creating a campaign
+class CampaignCreate(CampaignBase):
+    # Additional fields for creation
+    source: CampaignSource = CampaignSource.MANUAL
+    status: CampaignStatus = CampaignStatus.APPROVED
+    external_id: Optional[str] = None
+    priority: int = 0
+
+
+# Schema for updating a campaign
+class CampaignUpdate(BaseModel):
+    name: Optional[str] = None
+    description: Optional[str] = None
+    bank_id: Optional[int] = None
+    card_id: Optional[int] = None
+    category: Optional[CategoryEnum] = None
+    discount_type: Optional[DiscountType] = None
+    discount_value: Optional[float] = None
+    min_amount: Optional[float] = None
+    max_discount: Optional[float] = None
+    start_date: Optional[datetime] = None
+    end_date: Optional[datetime] = None
+    merchant_id: Optional[int] = None
+    is_active: Optional[bool] = None
+    requires_enrollment: Optional[bool] = None
+    enrollment_url: Optional[str] = None
+    priority: Optional[int] = None
+    status: Optional[CampaignStatus] = None
+
+
+# Schema for reading a campaign
+class CampaignRead(CampaignBase):
+    id: int
+    created_at: datetime
+    updated_at: Optional[datetime] = None
+    
+    class Config:
+        orm_mode = True
+
+
+# Schema for database models (compatible with existing code)
+class CampaignInDB(CampaignRead):
+    # Add any additional fields needed for database models
+    
+    class Config:
+        orm_mode = True
+
+
+# Schema specifically for pending campaigns
+class PendingCampaignRead(CampaignRead):
+    source: CampaignSource
+    status: CampaignStatus
+    external_id: Optional[str] = None
+    priority: int
+    last_sync_at: Optional[datetime] = None
+    review_notes: Optional[str] = None
+    
+    class Config:
+        orm_mode = True
+
+
+# Schema for campaign with bank and card details
+class CampaignWithDetailsRead(CampaignRead):
+    bank: Optional[Dict[str, Any]] = None
+    credit_card: Optional[Dict[str, Any]] = None
+    merchant: Optional[Dict[str, Any]] = None
+    
+    class Config:
+        orm_mode = True
+
+
+# Response schema for sync processes
+class CampaignImportResponse(BaseModel):
+    success: bool
+    message: str
+    synced_banks: Optional[int] = None
+    failed_banks: Optional[List[Dict[str, Any]]] = None
+    total_campaigns: Optional[int] = None
+    imported_campaigns: Optional[int] = None
+    updated_campaigns: Optional[int] = None
+    new_campaigns: Optional[int] = None
+    pending_approval: Optional[int] = None
+    auto_approved: Optional[int] = None
+
+
+# Schema for campaign approval/rejection responses
+class CampaignApproval(BaseModel):
+    success: bool
+    message: str
+    campaign_id: int
+
+
+# Campaign with relations
+class CampaignWithRelations(CampaignRead):
+    bank: BankInDB
+    credit_card: CreditCardInDB
+    merchant: Optional[MerchantInDB] = None
+
+    class Config:
+        orm_mode = True 
\ No newline at end of file
diff --git a/app/schemas/recommendation.py b/app/schemas/recommendation.py
new file mode 100644
index 0000000..d8706f2
--- /dev/null
+++ b/app/schemas/recommendation.py
@@ -0,0 +1,54 @@
+from datetime import datetime
+from typing import Optional, List, Dict, Any
+from pydantic import BaseModel, Field
+
+from app.schemas.campaign import CampaignWithRelations, CreditCardInDB
+
+
+class RecommendationRequest(BaseModel):
+    user_id: Optional[int] = None
+    session_id: Optional[str] = None
+    cart_amount: float = Field(..., gt=0)
+    cart_category: str
+    merchant_name: Optional[str] = None
+    user_cards: Optional[List[int]] = []  # List of credit card IDs the user has
+
+
+class CardRecommendation(BaseModel):
+    campaign_id: int
+    card_id: int
+    card_name: str
+    bank_name: str
+    discount_type: str
+    discount_value: float
+    final_amount: float
+    savings_amount: float
+    is_existing_card: bool
+    requires_enrollment: bool
+    enrollment_url: Optional[str] = None
+    application_url: Optional[str] = None
+    affiliate_code: Optional[str] = None
+    logo_url: Optional[str] = None
+    
+
+class RecommendationResponse(BaseModel):
+    request_id: str
+    timestamp: datetime
+    cart_amount: float
+    cart_category: str
+    merchant_name: Optional[str] = None
+    existing_card_recommendations: List[CardRecommendation] = []
+    new_card_recommendations: List[CardRecommendation] = []
+
+
+class RecommendationClickRequest(BaseModel):
+    recommendation_id: int
+    user_id: Optional[int] = None
+    session_id: Optional[str] = None
+    action_type: str = Field(..., pattern='^(card_apply|enroll|select)$')
+
+
+class RecommendationClickResponse(BaseModel):
+    success: bool
+    redirect_url: Optional[str] = None
+    message: str 
\ No newline at end of file
diff --git a/app/services/__init__.py b/app/services/__init__.py
new file mode 100644
index 0000000..3a86e8d
--- /dev/null
+++ b/app/services/__init__.py
@@ -0,0 +1 @@
+# Services module initialization 
\ No newline at end of file
diff --git a/app/services/bank_service.py b/app/services/bank_service.py
new file mode 100644
index 0000000..3ddf0a3
--- /dev/null
+++ b/app/services/bank_service.py
@@ -0,0 +1,198 @@
+import logging
+from typing import Dict, Any, Optional
+import aiohttp
+from aiohttp import ClientError
+from sqlalchemy.orm import Session
+
+from app.models.campaign import Bank, Campaign
+from app.utils.crypto import encrypt_data, decrypt_data
+
+logger = logging.getLogger(__name__)
+
+
+class BankService:
+    """Service for integrating with bank APIs for campaign enrollment"""
+    
+    def __init__(self, db: Session):
+        self.db = db
+    
+    async def enroll_in_campaign(
+        self,
+        campaign_id: int,
+        user_identifiers: Dict[str, Any]
+    ) -> Dict[str, Any]:
+        """
+        Enroll a user in a bank campaign through the bank's API
+        
+        Parameters:
+        - campaign_id: The ID of the campaign to enroll in
+        - user_identifiers: Dict containing user identifiers required by the bank
+          (may include masked card number, customer ID, phone, etc.)
+        
+        Returns:
+        - Dictionary with enrollment status and details
+        """
+        # Get campaign and bank details
+        campaign = self.db.query(Campaign).filter(Campaign.id == campaign_id).first()
+        if not campaign:
+            return {
+                "success": False,
+                "message": "Campaign not found"
+            }
+        
+        # Check if campaign requires enrollment
+        if not campaign.requires_enrollment:
+            return {
+                "success": True,
+                "message": "No enrollment required for this campaign"
+            }
+        
+        # Get bank API details
+        bank = campaign.bank
+        if not bank.api_base_url:
+            return {
+                "success": False,
+                "message": "Bank API integration not available"
+            }
+        
+        # Decrypt API credentials
+        api_key = decrypt_data(bank.api_key) if bank.api_key else None
+        api_secret = decrypt_data(bank.api_secret) if bank.api_secret else None
+        
+        if not api_key or not api_secret:
+            return {
+                "success": False,
+                "message": "Bank API credentials not configured"
+            }
+        
+        # Prepare enrollment request
+        enrollment_data = {
+            "campaign_id": campaign.id,
+            "campaign_reference": f"PAYVIYA-{campaign.id}",
+            "user_data": user_identifiers
+        }
+        
+        # Call bank API to enroll in the campaign
+        try:
+            response = await self._call_bank_api(
+                bank=bank,
+                endpoint="/campaigns/enroll",
+                method="POST",
+                data=enrollment_data,
+                api_key=api_key,
+                api_secret=api_secret
+            )
+            
+            return {
+                "success": response.get("success", False),
+                "message": response.get("message", "Enrollment request processed"),
+                "enrollment_id": response.get("enrollment_id"),
+                "status": response.get("status"),
+                "expiry": response.get("expiry")
+            }
+            
+        except Exception as e:
+            logger.error(f"Error during campaign enrollment: {str(e)}")
+            return {
+                "success": False,
+                "message": f"Enrollment failed: {str(e)}"
+            }
+    
+    async def check_enrollment_status(
+        self,
+        campaign_id: int,
+        enrollment_id: str
+    ) -> Dict[str, Any]:
+        """Check the status of a previous campaign enrollment"""
+        
+        # Get campaign and bank details
+        campaign = self.db.query(Campaign).filter(Campaign.id == campaign_id).first()
+        if not campaign:
+            return {
+                "success": False,
+                "message": "Campaign not found"
+            }
+        
+        # Get bank API details
+        bank = campaign.bank
+        if not bank.api_base_url:
+            return {
+                "success": False,
+                "message": "Bank API integration not available"
+            }
+        
+        # Decrypt API credentials
+        api_key = decrypt_data(bank.api_key) if bank.api_key else None
+        api_secret = decrypt_data(bank.api_secret) if bank.api_secret else None
+        
+        if not api_key or not api_secret:
+            return {
+                "success": False,
+                "message": "Bank API credentials not configured"
+            }
+        
+        # Call bank API to check enrollment status
+        try:
+            response = await self._call_bank_api(
+                bank=bank,
+                endpoint=f"/campaigns/enrollments/{enrollment_id}",
+                method="GET",
+                data=None,
+                api_key=api_key,
+                api_secret=api_secret
+            )
+            
+            return {
+                "success": response.get("success", False),
+                "status": response.get("status"),
+                "message": response.get("message", "Enrollment status checked"),
+                "enrollment_id": enrollment_id,
+                "expiry": response.get("expiry")
+            }
+            
+        except Exception as e:
+            logger.error(f"Error checking enrollment status: {str(e)}")
+            return {
+                "success": False,
+                "message": f"Status check failed: {str(e)}"
+            }
+    
+    async def _call_bank_api(
+        self,
+        bank: Bank,
+        endpoint: str,
+        method: str,
+        data: Optional[Dict[str, Any]],
+        api_key: str,
+        api_secret: str
+    ) -> Dict[str, Any]:
+        """Make an API call to a bank's API endpoint"""
+        
+        url = f"{bank.api_base_url}{endpoint}"
+        headers = {
+            "Content-Type": "application/json",
+            "X-API-Key": api_key,
+            "X-API-Secret": api_secret
+        }
+        
+        async with aiohttp.ClientSession() as session:
+            try:
+                if method.upper() == "GET":
+                    async with session.get(url, headers=headers) as response:
+                        response.raise_for_status()
+                        return await response.json()
+                        
+                elif method.upper() == "POST":
+                    async with session.post(url, headers=headers, json=data) as response:
+                        response.raise_for_status()
+                        return await response.json()
+                        
+                else:
+                    raise ValueError(f"Unsupported method: {method}")
+                    
+            except ClientError as e:
+                logger.error(f"Bank API error: {str(e)}")
+                raise
+            except Exception as e:
+                logger.error(f"Error calling bank API: {str(e)}")
+                raise 
\ No newline at end of file
diff --git a/app/services/campaign_sync_service.py b/app/services/campaign_sync_service.py
new file mode 100644
index 0000000..d21ce3f
--- /dev/null
+++ b/app/services/campaign_sync_service.py
@@ -0,0 +1,509 @@
+import logging
+import asyncio
+from datetime import datetime
+from typing import Dict, Any, List, Optional
+import aiohttp
+from sqlalchemy.orm import Session
+from sqlalchemy import and_, or_
+
+from app.models.campaign import Bank, Campaign, CampaignSource, CampaignStatus
+from app.utils.crypto import decrypt_data
+
+logger = logging.getLogger(__name__)
+
+
+class CampaignSyncService:
+    """Service for syncing campaigns from bank APIs and managing the approval process"""
+    
+    def __init__(self, db: Session):
+        self.db = db
+    
+    async def sync_all_banks(self) -> Dict[str, Any]:
+        """Sync campaigns from all banks that have campaign_sync_enabled"""
+        
+        banks = self.db.query(Bank).filter(Bank.campaign_sync_enabled == True).all()
+        if not banks:
+            return {
+                "success": True,
+                "message": "No banks configured for campaign syncing",
+                "synced_banks": 0,
+                "total_campaigns": 0
+            }
+        
+        total_campaigns = 0
+        synced_banks = 0
+        failed_banks = []
+        
+        for bank in banks:
+            try:
+                result = await self.sync_bank_campaigns(bank.id)
+                if result["success"]:
+                    total_campaigns += result["imported_campaigns"]
+                    synced_banks += 1
+                else:
+                    failed_banks.append({
+                        "bank_id": bank.id,
+                        "bank_name": bank.name,
+                        "error": result["message"]
+                    })
+            except Exception as e:
+                logger.error(f"Error syncing campaigns for bank {bank.name}: {str(e)}")
+                failed_banks.append({
+                    "bank_id": bank.id,
+                    "bank_name": bank.name,
+                    "error": str(e)
+                })
+        
+        return {
+            "success": True,
+            "message": f"Synced campaigns from {synced_banks} banks",
+            "synced_banks": synced_banks,
+            "failed_banks": failed_banks,
+            "total_campaigns": total_campaigns
+        }
+    
+    async def sync_bank_campaigns(self, bank_id: int) -> Dict[str, Any]:
+        """
+        Sync campaigns from a specific bank's API
+        
+        Parameters:
+        - bank_id: The ID of the bank to sync campaigns from
+        
+        Returns:
+        - Dictionary with sync status and details
+        """
+        # Get bank details
+        bank = self.db.query(Bank).filter(Bank.id == bank_id).first()
+        if not bank:
+            return {
+                "success": False,
+                "message": "Bank not found"
+            }
+        
+        if not bank.campaign_sync_enabled or not bank.campaign_sync_endpoint:
+            return {
+                "success": False,
+                "message": "Campaign sync not enabled for this bank"
+            }
+        
+        # Decrypt API credentials
+        api_key = decrypt_data(bank.api_key) if bank.api_key else None
+        api_secret = decrypt_data(bank.api_secret) if bank.api_secret else None
+        
+        if not api_key or not api_secret:
+            return {
+                "success": False,
+                "message": "Bank API credentials not configured"
+            }
+        
+        # Call bank API to get campaigns
+        try:
+            campaigns = await self._call_bank_api(
+                bank=bank,
+                endpoint=bank.campaign_sync_endpoint,
+                method="GET",
+                data=None,
+                api_key=api_key,
+                api_secret=api_secret
+            )
+            
+            if not campaigns or not isinstance(campaigns, list):
+                return {
+                    "success": False,
+                    "message": "Invalid campaign data format from bank API"
+                }
+            
+            # Process the imported campaigns
+            import_result = await self._process_imported_campaigns(
+                bank_id=bank.id,
+                campaigns=campaigns,
+                auto_approve=bank.auto_approve_campaigns
+            )
+            
+            # Update the last sync time
+            bank.last_campaign_sync_at = datetime.now()
+            self.db.commit()
+            
+            return {
+                "success": True,
+                "message": f"Successfully synced {import_result['imported_campaigns']} campaigns",
+                "imported_campaigns": import_result["imported_campaigns"],
+                "updated_campaigns": import_result["updated_campaigns"],
+                "new_campaigns": import_result["new_campaigns"],
+                "pending_approval": import_result["pending_approval"],
+                "auto_approved": import_result["auto_approved"]
+            }
+            
+        except Exception as e:
+            logger.error(f"Error syncing campaigns from bank {bank.name}: {str(e)}")
+            return {
+                "success": False,
+                "message": f"Sync failed: {str(e)}"
+            }
+    
+    async def _process_imported_campaigns(
+        self,
+        bank_id: int,
+        campaigns: List[Dict[str, Any]],
+        auto_approve: bool = False
+    ) -> Dict[str, int]:
+        """
+        Process imported campaigns from a bank API
+        
+        Parameters:
+        - bank_id: The bank ID these campaigns belong to
+        - campaigns: List of campaign data from the bank API
+        - auto_approve: Whether to automatically approve campaigns
+        
+        Returns:
+        - Stats about processed campaigns
+        """
+        imported_campaigns = 0
+        updated_campaigns = 0
+        new_campaigns = 0
+        pending_approval = 0
+        auto_approved = 0
+        
+        for campaign_data in campaigns:
+            external_id = campaign_data.get("external_id") or campaign_data.get("id")
+            
+            if not external_id:
+                logger.warning("Campaign without external ID, skipping")
+                continue
+            
+            # Check if this campaign already exists
+            existing_campaign = self.db.query(Campaign).filter(
+                and_(
+                    Campaign.bank_id == bank_id,
+                    Campaign.external_id == str(external_id),
+                    Campaign.source == CampaignSource.BANK_API
+                )
+            ).first()
+            
+            if existing_campaign:
+                # Update existing campaign
+                self._update_campaign_from_data(existing_campaign, campaign_data)
+                updated_campaigns += 1
+            else:
+                # Create new campaign
+                new_campaign = self._create_campaign_from_data(bank_id, campaign_data)
+                
+                if auto_approve:
+                    new_campaign.status = CampaignStatus.APPROVED
+                    auto_approved += 1
+                else:
+                    new_campaign.status = CampaignStatus.PENDING
+                    pending_approval += 1
+                
+                self.db.add(new_campaign)
+                new_campaigns += 1
+            
+            imported_campaigns += 1
+        
+        self.db.commit()
+        
+        return {
+            "imported_campaigns": imported_campaigns,
+            "updated_campaigns": updated_campaigns,
+            "new_campaigns": new_campaigns,
+            "pending_approval": pending_approval,
+            "auto_approved": auto_approved
+        }
+    
+    def _create_campaign_from_data(
+        self,
+        bank_id: int,
+        campaign_data: Dict[str, Any]
+    ) -> Campaign:
+        """Create a new Campaign object from imported data"""
+        
+        # Map external category to internal category
+        category = self._map_external_category(campaign_data.get("category", "other"))
+        
+        # Map external discount type to internal discount type
+        discount_type = self._map_external_discount_type(campaign_data.get("discount_type", "percentage"))
+        
+        # Create new campaign
+        campaign = Campaign(
+            name=campaign_data.get("name", "Unnamed Campaign"),
+            description=campaign_data.get("description", ""),
+            bank_id=bank_id,
+            card_id=campaign_data.get("card_id"),  # May need to map from external ID
+            category=category,
+            discount_type=discount_type,
+            discount_value=float(campaign_data.get("discount_value", 0)),
+            min_amount=float(campaign_data.get("min_amount", 0)),
+            max_discount=float(campaign_data.get("max_discount")) if campaign_data.get("max_discount") else None,
+            start_date=self._parse_date(campaign_data.get("start_date")),
+            end_date=self._parse_date(campaign_data.get("end_date")),
+            merchant_id=campaign_data.get("merchant_id"),  # May need to map from external ID
+            is_active=campaign_data.get("is_active", True),
+            requires_enrollment=campaign_data.get("requires_enrollment", False),
+            enrollment_url=campaign_data.get("enrollment_url"),
+            source=CampaignSource.BANK_API,
+            external_id=str(campaign_data.get("external_id") or campaign_data.get("id")),
+            last_sync_at=datetime.now()
+        )
+        
+        return campaign
+    
+    def _update_campaign_from_data(
+        self,
+        campaign: Campaign,
+        campaign_data: Dict[str, Any]
+    ) -> None:
+        """Update an existing Campaign object from imported data"""
+        
+        # Only update if the campaign is not edited manually
+        # If it's pending or approved, update it
+        if campaign.status in [CampaignStatus.PENDING, CampaignStatus.APPROVED]:
+            campaign.name = campaign_data.get("name", campaign.name)
+            campaign.description = campaign_data.get("description", campaign.description)
+            
+            # Only update card_id if provided and valid
+            if campaign_data.get("card_id"):
+                campaign.card_id = campaign_data.get("card_id")
+            
+            # Map category if provided
+            if campaign_data.get("category"):
+                campaign.category = self._map_external_category(campaign_data.get("category"))
+            
+            # Map discount_type if provided
+            if campaign_data.get("discount_type"):
+                campaign.discount_type = self._map_external_discount_type(campaign_data.get("discount_type"))
+            
+            # Update numeric values if provided
+            if campaign_data.get("discount_value") is not None:
+                campaign.discount_value = float(campaign_data.get("discount_value"))
+            
+            if campaign_data.get("min_amount") is not None:
+                campaign.min_amount = float(campaign_data.get("min_amount"))
+            
+            if campaign_data.get("max_discount") is not None:
+                campaign.max_discount = float(campaign_data.get("max_discount"))
+            
+            # Update dates if provided
+            if campaign_data.get("start_date"):
+                campaign.start_date = self._parse_date(campaign_data.get("start_date"))
+            
+            if campaign_data.get("end_date"):
+                campaign.end_date = self._parse_date(campaign_data.get("end_date"))
+            
+            # Update merchant if provided
+            if campaign_data.get("merchant_id"):
+                campaign.merchant_id = campaign_data.get("merchant_id")
+            
+            # Update boolean flags if provided
+            if campaign_data.get("is_active") is not None:
+                campaign.is_active = campaign_data.get("is_active")
+            
+            if campaign_data.get("requires_enrollment") is not None:
+                campaign.requires_enrollment = campaign_data.get("requires_enrollment")
+            
+            # Update enrollment URL if provided
+            if campaign_data.get("enrollment_url"):
+                campaign.enrollment_url = campaign_data.get("enrollment_url")
+            
+            # Update sync time
+            campaign.last_sync_at = datetime.now()
+    
+    def _map_external_category(self, external_category: str) -> str:
+        """Map external category to internal category enum"""
+        category_map = {
+            "electronics": "electronics",
+            "electronic": "electronics",
+            "tech": "electronics",
+            
+            "fashion": "fashion",
+            "clothing": "fashion",
+            "apparel": "fashion",
+            
+            "grocery": "grocery",
+            "supermarket": "grocery",
+            "food": "grocery",
+            
+            "travel": "travel",
+            "flight": "travel",
+            "hotel": "travel",
+            
+            "restaurant": "restaurant",
+            "dining": "restaurant",
+            "cafe": "restaurant",
+            
+            "fuel": "fuel",
+            "gas": "fuel",
+            "petrol": "fuel",
+            
+            "entertainment": "entertainment",
+            "movie": "entertainment",
+            "game": "entertainment"
+        }
+        
+        normalized = external_category.lower().strip()
+        return category_map.get(normalized, "other")
+    
+    def _map_external_discount_type(self, external_type: str) -> str:
+        """Map external discount type to internal discount type enum"""
+        type_map = {
+            "percentage": "percentage",
+            "percent": "percentage",
+            "%": "percentage",
+            
+            "cashback": "cashback",
+            "cash_back": "cashback",
+            "rebate": "cashback",
+            
+            "points": "points",
+            "point": "points",
+            "mile": "points",
+            "miles": "points",
+            
+            "installment": "installment",
+            "installments": "installment",
+            "payment_plan": "installment"
+        }
+        
+        normalized = external_type.lower().strip()
+        return type_map.get(normalized, "percentage")
+    
+    def _parse_date(self, date_str: Optional[str]) -> datetime:
+        """Parse date string from external API into datetime object"""
+        if not date_str:
+            # Default to current date if not provided
+            return datetime.now()
+        
+        try:
+            # Try different date formats
+            for fmt in ["%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]:
+                try:
+                    return datetime.strptime(date_str, fmt)
+                except ValueError:
+                    continue
+            
+            # If none of the formats work, default to now
+            return datetime.now()
+        except Exception:
+            return datetime.now()
+    
+    async def _call_bank_api(
+        self,
+        bank: Bank,
+        endpoint: str,
+        method: str,
+        data: Optional[Dict[str, Any]],
+        api_key: str,
+        api_secret: str
+    ) -> Any:
+        """Make an API call to a bank's API endpoint"""
+        
+        url = f"{bank.api_base_url}{endpoint}"
+        headers = {
+            "Content-Type": "application/json",
+            "X-API-Key": api_key,
+            "X-API-Secret": api_secret
+        }
+        
+        async with aiohttp.ClientSession() as session:
+            try:
+                if method.upper() == "GET":
+                    async with session.get(url, headers=headers) as response:
+                        response.raise_for_status()
+                        return await response.json()
+                        
+                elif method.upper() == "POST":
+                    async with session.post(url, headers=headers, json=data) as response:
+                        response.raise_for_status()
+                        return await response.json()
+                        
+                else:
+                    raise ValueError(f"Unsupported method: {method}")
+                    
+            except Exception as e:
+                logger.error(f"Error calling bank API: {str(e)}")
+                raise
+    
+    # Campaign approval methods
+    
+    def approve_campaign(
+        self, 
+        campaign_id: int,
+        admin_id: int,
+        review_notes: Optional[str] = None
+    ) -> Dict[str, Any]:
+        """Approve a pending campaign"""
+        
+        campaign = self.db.query(Campaign).filter(Campaign.id == campaign_id).first()
+        if not campaign:
+            return {
+                "success": False,
+                "message": "Campaign not found"
+            }
+        
+        if campaign.status != CampaignStatus.PENDING:
+            return {
+                "success": False,
+                "message": f"Campaign is not pending approval (current status: {campaign.status})"
+            }
+        
+        # Update campaign status
+        campaign.status = CampaignStatus.APPROVED
+        campaign.review_notes = review_notes
+        campaign.reviewed_by = admin_id
+        campaign.is_active = True
+        
+        self.db.commit()
+        
+        return {
+            "success": True,
+            "message": "Campaign approved successfully",
+            "campaign_id": campaign.id
+        }
+    
+    def reject_campaign(
+        self, 
+        campaign_id: int,
+        admin_id: int,
+        review_notes: Optional[str] = None
+    ) -> Dict[str, Any]:
+        """Reject a pending campaign"""
+        
+        campaign = self.db.query(Campaign).filter(Campaign.id == campaign_id).first()
+        if not campaign:
+            return {
+                "success": False,
+                "message": "Campaign not found"
+            }
+        
+        if campaign.status != CampaignStatus.PENDING:
+            return {
+                "success": False,
+                "message": f"Campaign is not pending approval (current status: {campaign.status})"
+            }
+        
+        # Update campaign status
+        campaign.status = CampaignStatus.REJECTED
+        campaign.review_notes = review_notes
+        campaign.reviewed_by = admin_id
+        campaign.is_active = False
+        
+        self.db.commit()
+        
+        return {
+            "success": True,
+            "message": "Campaign rejected",
+            "campaign_id": campaign.id
+        }
+    
+    def get_pending_campaigns(
+        self,
+        skip: int = 0,
+        limit: int = 100
+    ) -> List[Campaign]:
+        """Get campaigns that are pending approval"""
+        
+        return self.db.query(Campaign)\
+            .filter(Campaign.status == CampaignStatus.PENDING)\
+            .order_by(Campaign.created_at.desc())\
+            .offset(skip)\
+            .limit(limit)\
+            .all() 
\ No newline at end of file
diff --git a/app/services/recommendation_service.py b/app/services/recommendation_service.py
new file mode 100644
index 0000000..bad2ca0
--- /dev/null
+++ b/app/services/recommendation_service.py
@@ -0,0 +1,254 @@
+import uuid
+from datetime import datetime
+from typing import List, Optional, Dict, Any
+from sqlalchemy.orm import Session
+
+from app.models.campaign import Campaign, CreditCard, Bank, CategoryEnum
+from app.models.user import Recommendation, RecommendationClick, User
+from app.schemas.recommendation import RecommendationRequest, CardRecommendation, RecommendationResponse
+
+
+class RecommendationService:
+    """Service for generating card recommendations based on cart data"""
+    
+    def __init__(self, db: Session):
+        self.db = db
+    
+    def find_matching_campaigns(
+        self, 
+        cart_amount: float, 
+        cart_category: str,
+        merchant_name: Optional[str] = None
+    ) -> List[Campaign]:
+        """Find all active campaigns that match the transaction criteria"""
+        
+        now = datetime.now()
+        
+        # Start with all active campaigns within date range
+        query = self.db.query(Campaign).filter(
+            Campaign.is_active == True,
+            Campaign.start_date <= now,
+            Campaign.end_date >= now,
+            Campaign.min_amount <= cart_amount
+        )
+        
+        # Filter by category if provided
+        if cart_category:
+            try:
+                category_enum = CategoryEnum(cart_category.lower())
+                query = query.filter(Campaign.category == category_enum)
+            except ValueError:
+                # If not a valid enum, try to match string
+                pass
+        
+        # Filter by merchant if provided
+        if merchant_name:
+            from app.models.campaign import Merchant
+            query = query.join(Merchant).filter(Merchant.name.ilike(f"%{merchant_name}%"))
+        
+        return query.all()
+    
+    def calculate_savings(self, campaign: Campaign, cart_amount: float) -> Dict[str, float]:
+        """Calculate the final amount and savings for a given campaign and cart amount"""
+        
+        final_amount = cart_amount
+        savings = 0.0
+        
+        if campaign.discount_type == "percentage":
+            savings = cart_amount * (campaign.discount_value / 100)
+            if campaign.max_discount and savings > campaign.max_discount:
+                savings = campaign.max_discount
+            final_amount = cart_amount - savings
+            
+        elif campaign.discount_type == "cashback":
+            savings = campaign.discount_value
+            if cart_amount * 0.3 < savings:  # Cap cashback at 30% of purchase
+                savings = cart_amount * 0.3
+            # Final amount stays the same for cashback
+            
+        elif campaign.discount_type == "points":
+            # Points don't affect final amount, but represent value
+            # Assuming 1 point = 0.01 currency units
+            savings = campaign.discount_value * 0.01
+            # Final amount stays the same for points
+            
+        # For installment type, simply pass through (no direct savings)
+        
+        return {
+            "final_amount": final_amount,
+            "savings_amount": savings
+        }
+    
+    def create_card_recommendation(
+        self, 
+        campaign: Campaign,
+        cart_amount: float,
+        is_existing_card: bool
+    ) -> CardRecommendation:
+        """Create a card recommendation object from a campaign"""
+        
+        card = campaign.credit_card
+        bank = campaign.bank
+        
+        calculation = self.calculate_savings(campaign, cart_amount)
+        
+        return CardRecommendation(
+            campaign_id=campaign.id,
+            card_id=card.id,
+            card_name=card.name,
+            bank_name=bank.name,
+            discount_type=campaign.discount_type,
+            discount_value=campaign.discount_value,
+            final_amount=calculation["final_amount"],
+            savings_amount=calculation["savings_amount"],
+            is_existing_card=is_existing_card,
+            requires_enrollment=campaign.requires_enrollment,
+            enrollment_url=str(campaign.enrollment_url) if campaign.enrollment_url else None,
+            application_url=str(card.application_url) if not is_existing_card else None,
+            affiliate_code=card.affiliate_code if not is_existing_card else None,
+            logo_url=str(card.logo_url) if card.logo_url else None
+        )
+    
+    def get_recommendations(self, request: RecommendationRequest) -> RecommendationResponse:
+        """Generate card recommendations based on the request"""
+        
+        # Find matching campaigns
+        matching_campaigns = self.find_matching_campaigns(
+            request.cart_amount,
+            request.cart_category,
+            request.merchant_name
+        )
+        
+        # Get user's cards if user_id is provided
+        user_card_ids = set(request.user_cards or [])
+        if request.user_id:
+            user = self.db.query(User).filter(User.id == request.user_id).first()
+            if user:
+                for card in user.credit_cards:
+                    user_card_ids.add(card.id)
+        
+        # Create recommendations
+        existing_card_recommendations = []
+        new_card_recommendations = []
+        
+        # Process matching campaigns
+        for campaign in matching_campaigns:
+            card_id = campaign.card_id
+            
+            # Check if user has this card
+            if card_id in user_card_ids:
+                recommendation = self.create_card_recommendation(
+                    campaign, request.cart_amount, True
+                )
+                existing_card_recommendations.append(recommendation)
+            else:
+                recommendation = self.create_card_recommendation(
+                    campaign, request.cart_amount, False
+                )
+                new_card_recommendations.append(recommendation)
+        
+        # Sort recommendations by savings amount (highest first)
+        existing_card_recommendations.sort(
+            key=lambda x: x.savings_amount, reverse=True
+        )
+        new_card_recommendations.sort(
+            key=lambda x: x.savings_amount, reverse=True
+        )
+        
+        # Create response
+        response = RecommendationResponse(
+            request_id=str(uuid.uuid4()),
+            timestamp=datetime.now(),
+            cart_amount=request.cart_amount,
+            cart_category=request.cart_category,
+            merchant_name=request.merchant_name,
+            existing_card_recommendations=existing_card_recommendations[:3],  # Top 3
+            new_card_recommendations=new_card_recommendations[:3]  # Top 3
+        )
+        
+        # Store recommendation in database
+        self._store_recommendations(request, response)
+        
+        return response
+    
+    def _store_recommendations(
+        self, 
+        request: RecommendationRequest, 
+        response: RecommendationResponse
+    ) -> None:
+        """Store generated recommendations in the database for analytics"""
+        
+        # Store each recommendation
+        all_recommendations = (
+            [(rec, True) for rec in response.existing_card_recommendations] +
+            [(rec, False) for rec in response.new_card_recommendations]
+        )
+        
+        for rec, is_existing in all_recommendations:
+            db_recommendation = Recommendation(
+                user_id=request.user_id,
+                session_id=request.session_id or response.request_id,
+                campaign_id=rec.campaign_id,
+                merchant_name=request.merchant_name,
+                cart_amount=request.cart_amount,
+                cart_category=request.cart_category,
+                discount_amount=rec.savings_amount,
+                original_amount=request.cart_amount,
+                is_existing_card=is_existing,
+                needs_enrollment=rec.requires_enrollment
+            )
+            self.db.add(db_recommendation)
+        
+        self.db.commit()
+    
+    def track_recommendation_click(
+        self,
+        recommendation_id: int,
+        user_id: Optional[int],
+        session_id: Optional[str],
+        action_type: str
+    ) -> Dict[str, Any]:
+        """Track when a user clicks on a recommendation"""
+        
+        # Find the recommendation
+        recommendation = self.db.query(Recommendation).filter(
+            Recommendation.id == recommendation_id
+        ).first()
+        
+        if not recommendation:
+            return {
+                "success": False,
+                "message": "Recommendation not found"
+            }
+        
+        # Create click record
+        click = RecommendationClick(
+            user_id=user_id,
+            session_id=session_id or recommendation.session_id,
+            recommendation_id=recommendation_id,
+            action_type=action_type
+        )
+        self.db.add(click)
+        self.db.commit()
+        
+        # Determine redirect URL based on action type
+        redirect_url = None
+        if action_type == "card_apply":
+            card = self.db.query(CreditCard).join(Campaign).filter(
+                Campaign.id == recommendation.campaign_id
+            ).first()
+            if card:
+                redirect_url = str(card.application_url)
+                
+        elif action_type == "enroll":
+            campaign = self.db.query(Campaign).filter(
+                Campaign.id == recommendation.campaign_id
+            ).first()
+            if campaign and campaign.enrollment_url:
+                redirect_url = str(campaign.enrollment_url)
+        
+        return {
+            "success": True,
+            "redirect_url": redirect_url,
+            "message": f"Successfully tracked {action_type} action"
+        } 
\ No newline at end of file
diff --git a/app/tasks/campaign_sync_task.py b/app/tasks/campaign_sync_task.py
new file mode 100644
index 0000000..1b593f4
--- /dev/null
+++ b/app/tasks/campaign_sync_task.py
@@ -0,0 +1,83 @@
+import asyncio
+import logging
+from datetime import datetime
+from typing import Dict, Any
+import time
+import traceback
+
+from app.db.base import SessionLocal
+from app.services.campaign_sync_service import CampaignSyncService
+
+logger = logging.getLogger(__name__)
+
+async def sync_campaigns() -> Dict[str, Any]:
+    """
+    Task to sync campaigns from all configured banks
+    This can be scheduled to run periodically
+    """
+    logger.info("Starting campaign sync task")
+    start_time = time.time()
+    
+    db = SessionLocal()
+    try:
+        campaign_sync_service = CampaignSyncService(db)
+        
+        # Perform the sync
+        result = await campaign_sync_service.sync_all_banks()
+        
+        # Log the result
+        execution_time = time.time() - start_time
+        logger.info(
+            f"Campaign sync completed in {execution_time:.2f}s. "
+            f"Synced {result['synced_banks']} banks, "
+            f"{result['total_campaigns']} campaigns. "
+            f"Failed banks: {len(result.get('failed_banks', []))}"
+        )
+        
+        if result.get('failed_banks'):
+            for failed_bank in result['failed_banks']:
+                logger.error(
+                    f"Failed to sync campaigns for bank {failed_bank['bank_name']} (ID: {failed_bank['bank_id']}): "
+                    f"{failed_bank['error']}"
+                )
+        
+        return result
+    except Exception as e:
+        logger.error(f"Error in campaign sync task: {str(e)}")
+        logger.error(traceback.format_exc())
+        return {
+            "success": False,
+            "message": f"Error in campaign sync task: {str(e)}"
+        }
+    finally:
+        db.close()
+
+def schedule_campaign_sync(scheduler):
+    """
+    Schedule the campaign sync task to run periodically
+    
+    Parameters:
+    - scheduler: APScheduler instance
+    """
+    # Schedule to run every day at 2:00 AM
+    scheduler.add_job(
+        sync_campaigns,
+        'cron',
+        hour=2,
+        minute=0,
+        id='campaign_sync_task',
+        replace_existing=True
+    )
+    
+    logger.info("Campaign sync task scheduled to run daily at 2:00 AM")
+    
+    # You can also add a job to run immediately on startup
+    scheduler.add_job(
+        sync_campaigns,
+        'date',
+        run_date=datetime.now(),
+        id='campaign_sync_startup',
+        replace_existing=True
+    )
+    
+    logger.info("Campaign sync task scheduled to run on startup") 
\ No newline at end of file
diff --git a/app/tests/test_admin_api.py b/app/tests/test_admin_api.py
new file mode 100644
index 0000000..0eebcf2
--- /dev/null
+++ b/app/tests/test_admin_api.py
@@ -0,0 +1,261 @@
+import unittest
+import requests
+import json
+from typing import Dict, Any, List
+
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestAdminAPI(unittest.TestCase):
+    def setUp(self):
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+    
+    # Bank API methods
+    def list_banks(self, skip=0, limit=100) -> List[Dict[str, Any]]:
+        """List all banks"""
+        url = f"{self.base_url}/admin/banks"
+        
+        params = {
+            "skip": skip,
+            "limit": limit
+        }
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def create_bank(self, bank_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Create a new bank"""
+        url = f"{self.base_url}/admin/banks"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(bank_data, indent=2)}")
+        
+        response = requests.post(url, json=bank_data)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    # Credit Card API methods
+    def list_credit_cards(self, bank_id=None, skip=0, limit=100) -> List[Dict[str, Any]]:
+        """List all credit cards, optionally filtered by bank"""
+        url = f"{self.base_url}/admin/credit-cards"
+        
+        params = {
+            "bank_id": bank_id,
+            "skip": skip,
+            "limit": limit
+        }
+        
+        # Remove None values
+        params = {k: v for k, v in params.items() if v is not None}
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def create_credit_card(self, card_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Create a new credit card"""
+        url = f"{self.base_url}/admin/credit-cards"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(card_data, indent=2)}")
+        
+        response = requests.post(url, json=card_data)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    # Merchant API methods
+    def list_merchants(self, skip=0, limit=100) -> List[Dict[str, Any]]:
+        """List all merchants"""
+        url = f"{self.base_url}/admin/merchants"
+        
+        params = {
+            "skip": skip,
+            "limit": limit
+        }
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def create_merchant(self, merchant_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Create a new merchant"""
+        url = f"{self.base_url}/admin/merchants"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(merchant_data, indent=2)}")
+        
+        response = requests.post(url, json=merchant_data)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    # Analytics API methods
+    def get_recommendation_stats(self, days=30) -> Dict[str, Any]:
+        """Get recommendation statistics"""
+        url = f"{self.base_url}/admin/analytics/recommendations"
+        
+        params = {
+            "days": days
+        }
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def get_campaign_stats(self, days=30) -> Dict[str, Any]:
+        """Get campaign performance statistics"""
+        url = f"{self.base_url}/admin/analytics/campaigns"
+        
+        params = {
+            "days": days
+        }
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    # Test methods
+    def test_list_banks(self):
+        """Test listing all banks"""
+        result = self.list_banks()
+        
+        # Verify response structure
+        self.assertIsInstance(result, list)
+        
+        # If there are banks, check their structure
+        if result:
+            bank = result[0]
+            self.assertIn("id", bank)
+            self.assertIn("name", bank)
+    
+    def test_list_credit_cards(self):
+        """Test listing all credit cards"""
+        result = self.list_credit_cards()
+        
+        # Verify response structure
+        self.assertIsInstance(result, list)
+        
+        # If there are credit cards, check their structure
+        if result:
+            card = result[0]
+            self.assertIn("id", card)
+            self.assertIn("name", card)
+            self.assertIn("bank_id", card)
+    
+    def test_list_merchants(self):
+        """Test listing all merchants"""
+        result = self.list_merchants()
+        
+        # Verify response structure
+        self.assertIsInstance(result, list)
+        
+        # If there are merchants, check their structure
+        if result:
+            merchant = result[0]
+            self.assertIn("id", merchant)
+            self.assertIn("name", merchant)
+    
+    def test_get_recommendation_stats(self):
+        """Test getting recommendation statistics"""
+        result = self.get_recommendation_stats(days=30)
+        
+        # Verify response structure
+        self.assertIn("period_days", result)
+        self.assertEqual(result["period_days"], 30)
+        
+        self.assertIn("total_recommendations", result)
+        self.assertIn("total_clicks", result)
+        self.assertIn("conversion_rate", result)
+        self.assertIn("clicks_by_type", result)
+    
+    def test_get_campaign_stats(self):
+        """Test getting campaign statistics"""
+        result = self.get_campaign_stats(days=30)
+        
+        # Verify response structure
+        self.assertIn("period_days", result)
+        
+        # Other fields may be empty arrays if no data, but should exist
+        self.assertIn("campaigns", result)
+
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_analytics_integration.py b/app/tests/test_analytics_integration.py
new file mode 100644
index 0000000..8644fc3
--- /dev/null
+++ b/app/tests/test_analytics_integration.py
@@ -0,0 +1,224 @@
+import unittest
+import json
+import requests
+from typing import Dict, Any, Optional
+
+# Set the base URL - this should be a running instance of your API
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestAnalyticsIntegration(unittest.TestCase):
+    """Integration tests for analytics endpoints and their interdependence with other API actions"""
+    
+    def setUp(self):
+        """Setup for integration tests - ensures API is running"""
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+        
+        # Check if the API is running - if not, skip all tests
+        try:
+            response = requests.get(f"{self.base_url}/campaigns/")
+            self.api_available = response.status_code == 200
+        except:
+            self.api_available = False
+    
+    def log_request_response(self, method: str, url: str, 
+                            payload: Optional[Dict] = None, 
+                            response: Optional[requests.Response] = None):
+        """Helper method to log request and response details"""
+        if not self.verbose:
+            return
+            
+        print(f"\n=== {method} REQUEST ===")
+        print(f"URL: {url}")
+        if payload:
+            print(f"Payload: {json.dumps(payload, indent=2)}")
+        
+        if response:
+            print(f"\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            try:
+                print(f"Response: {json.dumps(response.json(), indent=2)}")
+            except:
+                print(f"Response: {response.text}")
+    
+    def get_campaign_analytics(self, days: int = 30) -> Dict[str, Any]:
+        """Get campaign analytics for the specified period"""
+        url = f"{self.base_url}/admin/analytics/campaigns"
+        params = {"days": days}
+        
+        response = requests.get(url, params=params)
+        self.log_request_response("GET", url, payload=params, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to get campaign analytics")
+        return response.json()
+    
+    def get_recommendation_analytics(self, days: int = 30) -> Dict[str, Any]:
+        """Get recommendation analytics for the specified period"""
+        url = f"{self.base_url}/admin/analytics/recommendations"
+        params = {"days": days}
+        
+        response = requests.get(url, params=params)
+        self.log_request_response("GET", url, payload=params, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to get recommendation analytics")
+        return response.json()
+    
+    def generate_recommendation_and_track(self, 
+                                        cart_data: Dict[str, Any],
+                                        track_click: bool = True) -> Dict[str, Any]:
+        """Generate a recommendation and optionally track a click on it"""
+        # Get recommendation
+        url = f"{self.base_url}/recommendations/"
+        response = requests.post(url, json=cart_data)
+        self.log_request_response("POST", url, payload=cart_data, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to get recommendation")
+        recommendations = response.json()
+        
+        # Track a click if requested and if there are recommendations
+        if track_click:
+            recommendation = None
+            if recommendations["existing_card_recommendations"]:
+                recommendation = recommendations["existing_card_recommendations"][0]
+            elif recommendations["new_card_recommendations"]:
+                recommendation = recommendations["new_card_recommendations"][0]
+                
+            if recommendation:
+                click_url = f"{self.base_url}/recommendations/click"
+                click_data = {
+                    "recommendation_id": recommendation["campaign_id"],
+                    "action_type": "select"
+                }
+                
+                if "user_id" in cart_data:
+                    click_data["user_id"] = cart_data["user_id"]
+                    
+                click_response = requests.post(click_url, json=click_data)
+                self.log_request_response("POST", click_url, payload=click_data, response=click_response)
+                
+                self.assertEqual(click_response.status_code, 200, "Failed to track click")
+        
+        return recommendations
+    
+    def test_analytics_after_recommendations(self):
+        """Test that analytics data updates after making recommendation requests"""
+        if not self.api_available:
+            self.skipTest("API is not available - skipping integration test")
+        
+        # Step 1: Get initial analytics data
+        initial_campaign_analytics = self.get_campaign_analytics()
+        initial_recommendation_analytics = self.get_recommendation_analytics()
+        
+        # Record the initial counts
+        initial_rec_count = initial_recommendation_analytics["total_recommendations"]
+        initial_click_count = initial_recommendation_analytics["total_clicks"]
+        
+        # Step 2: Generate some new recommendations
+        cart_data_1 = {
+            "cart_amount": 500,
+            "cart_category": "electronics",
+            "merchant_name": "Amazon"
+        }
+        
+        cart_data_2 = {
+            "cart_amount": 300,
+            "cart_category": "fuel",
+            "merchant_name": "Shell"
+        }
+        
+        # Generate recommendations and track clicks
+        self.generate_recommendation_and_track(cart_data_1)
+        self.generate_recommendation_and_track(cart_data_2)
+        
+        # Step 3: Check updated analytics
+        updated_campaign_analytics = self.get_campaign_analytics()
+        updated_recommendation_analytics = self.get_recommendation_analytics()
+        
+        # Verify that the counts have increased
+        updated_rec_count = updated_recommendation_analytics["total_recommendations"]
+        updated_click_count = updated_recommendation_analytics["total_clicks"]
+        
+        self.assertGreater(updated_rec_count, initial_rec_count, 
+                          "Recommendation count didn't increase after new recommendations")
+        self.assertGreater(updated_click_count, initial_click_count,
+                          "Click count didn't increase after tracking clicks")
+        
+        # Check that we've increased by 2 recommendations and 2 clicks
+        self.assertEqual(updated_rec_count, initial_rec_count + 2,
+                        f"Expected {initial_rec_count + 2} recs, got {updated_rec_count}")
+        self.assertEqual(updated_click_count, initial_click_count + 2,
+                        f"Expected {initial_click_count + 2} clicks, got {updated_click_count}")
+        
+        print("Successfully verified analytics integration")
+    
+    def test_campaign_impression_tracking(self):
+        """Test that campaign impressions are tracked correctly in analytics"""
+        if not self.api_available:
+            self.skipTest("API is not available - skipping integration test")
+        
+        # Step 1: Get initial campaign analytics
+        initial_analytics = self.get_campaign_analytics()
+        
+        # Find a campaign to test with - use Amazon campaign
+        campaign_id = 1  # Amazon campaign
+        
+        # Get its initial impression count
+        campaign_data = None
+        for campaign in initial_analytics["campaigns"]:
+            if campaign["campaign_id"] == campaign_id:
+                campaign_data = campaign
+                break
+                
+        if not campaign_data:
+            self.skipTest(f"Campaign with ID {campaign_id} not found in analytics")
+            
+        initial_impressions = campaign_data["impression_count"]
+        initial_clicks = campaign_data["click_count"]
+        
+        # Step 2: Generate new recommendations for this campaign
+        cart_data = {
+            "cart_amount": 200,
+            "cart_category": "electronics",
+            "merchant_name": "Amazon"
+        }
+        
+        # Make the recommendation request with click tracking
+        self.generate_recommendation_and_track(cart_data)
+        
+        # Step 3: Check updated campaign analytics
+        updated_analytics = self.get_campaign_analytics()
+        
+        # Find the campaign in the updated data
+        updated_campaign_data = None
+        for campaign in updated_analytics["campaigns"]:
+            if campaign["campaign_id"] == campaign_id:
+                updated_campaign_data = campaign
+                break
+                
+        self.assertIsNotNone(updated_campaign_data, f"Campaign with ID {campaign_id} not found in updated analytics")
+        
+        updated_impressions = updated_campaign_data["impression_count"]
+        updated_clicks = updated_campaign_data["click_count"]
+        
+        # Verify impression and click counts increased
+        self.assertGreater(updated_impressions, initial_impressions,
+                        f"Expected impressions to increase, but got {initial_impressions} -> {updated_impressions}")
+        self.assertGreater(updated_clicks, initial_clicks,
+                        f"Expected clicks to increase, but got {initial_clicks} -> {updated_clicks}")
+        
+        # Verify CTR calculation is reasonable (should be between 0 and 100)
+        self.assertGreaterEqual(updated_campaign_data["ctr"], 0,
+                            f"CTR should be >= 0, got {updated_campaign_data['ctr']}")
+        self.assertLessEqual(updated_campaign_data["ctr"], 100,
+                          f"CTR should be <= 100, got {updated_campaign_data['ctr']}")
+        
+        # Verify CTR calculation is mathematically correct
+        expected_ctr = (updated_clicks / updated_impressions) * 100 if updated_impressions > 0 else 0
+        self.assertAlmostEqual(updated_campaign_data["ctr"], expected_ctr, 
+                              msg=f"Expected CTR of {expected_ctr}, got {updated_campaign_data['ctr']}", 
+                              delta=0.1)
+        
+        print(f"Successfully verified campaign impression tracking for campaign {campaign_id}")
+
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_bank_api.py b/app/tests/test_bank_api.py
new file mode 100644
index 0000000..c388b32
--- /dev/null
+++ b/app/tests/test_bank_api.py
@@ -0,0 +1,170 @@
+import unittest
+import requests
+import json
+import uuid
+from unittest.mock import patch, Mock
+from typing import Dict, Any
+
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestBankAPI(unittest.TestCase):
+    def setUp(self):
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+        
+    def enroll_in_campaign(self, campaign_id: int, 
+                         user_identifiers: Dict[str, Any]) -> Dict[str, Any]:
+        """Enroll a user in a specific bank campaign"""
+        url = f"{self.base_url}/banks/campaigns/{campaign_id}/enroll"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(user_identifiers, indent=2)}")
+        
+        response = requests.post(url, json=user_identifiers)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def check_enrollment_status(self, campaign_id: int, 
+                              enrollment_id: str) -> Dict[str, Any]:
+        """Check the status of a previous campaign enrollment"""
+        url = f"{self.base_url}/banks/campaigns/{campaign_id}/enrollments/{enrollment_id}"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+        
+        response = requests.get(url)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    @patch('requests.post')
+    def test_enroll_in_campaign(self, mock_post):
+        """Test enrolling a user in a campaign - requires a valid campaign ID"""
+        # Mock the response for the campaigns API
+        campaigns_url = f"{self.base_url}/campaigns/"
+        mock_campaigns_response = Mock()
+        mock_campaigns_response.status_code = 200
+        mock_campaigns_response.json.return_value = [
+            {
+                "id": 1,
+                "name": "Test Campaign",
+                "bank_id": 1,
+                "requires_enrollment": True
+            }
+        ]
+        
+        # Mock the enrollment response
+        mock_enrollment_response = Mock()
+        mock_enrollment_response.status_code = 200
+        mock_enrollment_response.json.return_value = {
+            "success": True,
+            "enrollment_id": str(uuid.uuid4()),
+            "status": "approved",
+            "expiry": "2025-12-31T23:59:59"
+        }
+        
+        # Configure the mock to return different responses for different URLs
+        def side_effect(url, json=None, **kwargs):
+            if url == campaigns_url:
+                return mock_campaigns_response
+            else:
+                return mock_enrollment_response
+                
+        mock_post.side_effect = side_effect
+        
+        # Test enrollment with mock user data
+        user_identifiers = {
+            "masked_card_number": "1234",
+            "phone_number": "5551234567"
+        }
+        
+        # Use a mock to replace the real enroll_in_campaign call
+        with patch.object(self, 'enroll_in_campaign') as mock_enroll:
+            mock_enroll.return_value = mock_enrollment_response.json()
+            result = mock_enroll(1, user_identifiers)
+            
+            # Verify response structure
+            self.assertIn("success", result)
+            
+            # If enrollment was successful, enrollment_id should be present
+            if result["success"]:
+                self.assertIn("enrollment_id", result)
+    
+    @patch('requests.get')
+    @patch('requests.post')
+    def test_check_enrollment_status(self, mock_post, mock_get):
+        """Test checking enrollment status - requires a valid enrollment"""
+        # Mock the campaigns API response
+        campaigns_url = f"{self.base_url}/campaigns/"
+        mock_campaigns_response = Mock()
+        mock_campaigns_response.status_code = 200
+        mock_campaigns_response.json.return_value = [
+            {
+                "id": 1,
+                "name": "Test Campaign",
+                "bank_id": 1,
+                "requires_enrollment": True
+            }
+        ]
+        
+        # Mock the enrollment response
+        enrollment_id = str(uuid.uuid4())
+        mock_enrollment_response = Mock()
+        mock_enrollment_response.status_code = 200
+        mock_enrollment_response.json.return_value = {
+            "success": True,
+            "enrollment_id": enrollment_id,
+            "status": "approved",
+            "expiry": "2025-12-31T23:59:59"
+        }
+        
+        # Mock the status check response
+        mock_status_response = Mock()
+        mock_status_response.status_code = 200
+        mock_status_response.json.return_value = {
+            "success": True,
+            "status": "approved",
+            "message": "Enrollment is active",
+            "enrollment_id": enrollment_id,
+            "expiry": "2025-12-31T23:59:59"
+        }
+        
+        # Set up the post mock
+        mock_post.return_value = mock_enrollment_response
+        
+        # Set up the get mock
+        mock_get.return_value = mock_status_response
+        
+        # Use mocks to replace real API calls
+        with patch.object(self, 'enroll_in_campaign') as mock_enroll:
+            mock_enroll.return_value = mock_enrollment_response.json()
+            
+            with patch.object(self, 'check_enrollment_status') as mock_check:
+                mock_check.return_value = mock_status_response.json()
+                
+                # Call the mocked function
+                result = mock_check(1, enrollment_id)
+                
+                # Verify response structure
+                self.assertIn("success", result)
+                self.assertIn("status", result)
+                
+                # Status should be one of the expected values
+                self.assertIn(result["status"], ["pending", "approved", "rejected"])
+
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_campaign_api.py b/app/tests/test_campaign_api.py
new file mode 100644
index 0000000..205c1e6
--- /dev/null
+++ b/app/tests/test_campaign_api.py
@@ -0,0 +1,163 @@
+import unittest
+import requests
+import json
+from typing import Dict, Any
+
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestCampaignAPI(unittest.TestCase):
+    def setUp(self):
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+        
+    def list_campaigns(self, bank_id=None, card_id=None, category=None, 
+                      is_active=True, skip=0, limit=100) -> Dict[str, Any]:
+        """Get a list of campaigns with optional filters"""
+        url = f"{self.base_url}/campaigns/"
+        
+        params = {
+            "bank_id": bank_id,
+            "card_id": card_id,
+            "category": category,
+            "is_active": is_active,
+            "skip": skip,
+            "limit": limit
+        }
+        
+        # Remove None values
+        params = {k: v for k, v in params.items() if v is not None}
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+            print(f"Params: {json.dumps(params, indent=2)}")
+        
+        response = requests.get(url, params=params)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def get_campaign(self, campaign_id: int) -> Dict[str, Any]:
+        """Get details of a specific campaign"""
+        url = f"{self.base_url}/campaigns/{campaign_id}"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: GET")
+        
+        response = requests.get(url)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def create_campaign(self, campaign_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Create a new campaign"""
+        url = f"{self.base_url}/campaigns/"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(campaign_data, indent=2)}")
+        
+        response = requests.post(url, json=campaign_data)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def update_campaign(self, campaign_id: int, 
+                       update_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Update an existing campaign"""
+        url = f"{self.base_url}/campaigns/{campaign_id}"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: PUT")
+            print(f"Payload: {json.dumps(update_data, indent=2)}")
+        
+        response = requests.put(url, json=update_data)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def delete_campaign(self, campaign_id: int) -> Dict[str, Any]:
+        """Delete (deactivate) a campaign"""
+        url = f"{self.base_url}/campaigns/{campaign_id}"
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: DELETE")
+        
+        response = requests.delete(url)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def test_list_campaigns(self):
+        """Test getting a list of campaigns"""
+        result = self.list_campaigns()
+        
+        # Verify response structure
+        self.assertIsInstance(result, list)
+        
+        # If there are campaigns, check their structure
+        if result:
+            campaign = result[0]
+            self.assertIn("id", campaign)
+            self.assertIn("name", campaign)
+            self.assertIn("bank_id", campaign)
+            self.assertIn("card_id", campaign)
+            self.assertIn("discount_type", campaign)
+            self.assertIn("discount_value", campaign)
+    
+    def test_get_campaign(self):
+        """Test getting a specific campaign - requires an existing campaign ID"""
+        # First, get a list of campaigns to find an ID to use
+        campaigns = self.list_campaigns()
+        
+        # Skip test if no campaigns exist
+        if not campaigns:
+            self.skipTest("No campaigns available to test with")
+        
+        # Get the first campaign's ID
+        campaign_id = campaigns[0]["id"]
+        
+        # Get the specific campaign
+        result = self.get_campaign(campaign_id)
+        
+        # Verify response
+        self.assertEqual(result["id"], campaign_id)
+        self.assertIn("name", result)
+        self.assertIn("bank", result)
+        self.assertIn("credit_card", result)
+        
+        # Check that related objects are included
+        self.assertIn("name", result["bank"])
+        self.assertIn("name", result["credit_card"])
+
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_integration.py b/app/tests/test_integration.py
new file mode 100644
index 0000000..f25db6f
--- /dev/null
+++ b/app/tests/test_integration.py
@@ -0,0 +1,226 @@
+import unittest
+import os
+import json
+import requests
+from typing import Dict, Any, List, Optional
+from datetime import datetime, timedelta
+
+# Set the base URL - this should be a running instance of your API
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestIntegrationFlow(unittest.TestCase):
+    """Integration tests that test multiple API components working together"""
+    
+    def setUp(self):
+        """Setup for integration tests - ensures API is running"""
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+        
+        # Check if the API is running - if not, skip all tests
+        try:
+            response = requests.get(f"{self.base_url}/campaigns/")
+            self.api_available = response.status_code == 200
+        except:
+            self.api_available = False
+    
+    def tearDown(self):
+        """Any necessary cleanup"""
+        pass
+    
+    def log_request_response(self, method: str, url: str, 
+                            payload: Optional[Dict] = None, 
+                            response: Optional[requests.Response] = None):
+        """Helper method to log request and response details"""
+        if not self.verbose:
+            return
+            
+        print(f"\n=== {method} REQUEST ===")
+        print(f"URL: {url}")
+        if payload:
+            print(f"Payload: {json.dumps(payload, indent=2)}")
+        
+        if response:
+            print(f"\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            try:
+                print(f"Response: {json.dumps(response.json(), indent=2)}")
+            except:
+                print(f"Response: {response.text}")
+    
+    def get_campaigns(self) -> List[Dict[str, Any]]:
+        """Get all active campaigns"""
+        url = f"{self.base_url}/campaigns/"
+        params = {"is_active": True}
+        
+        response = requests.get(url, params=params)
+        self.log_request_response("GET", url, payload=params, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to get campaigns")
+        return response.json()
+    
+    def get_campaign_details(self, campaign_id: int) -> Dict[str, Any]:
+        """Get details for a specific campaign"""
+        url = f"{self.base_url}/campaigns/{campaign_id}"
+        
+        response = requests.get(url)
+        self.log_request_response("GET", url, response=response)
+        
+        self.assertEqual(response.status_code, 200, f"Failed to get campaign {campaign_id}")
+        return response.json()
+    
+    def get_recommendations(self, cart_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Get recommendations based on cart data"""
+        url = f"{self.base_url}/recommendations/"
+        
+        response = requests.post(url, json=cart_data)
+        self.log_request_response("POST", url, payload=cart_data, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to get recommendations")
+        return response.json()
+    
+    def track_recommendation_click(self, recommendation_id: int, action_type: str = "select",
+                                 user_id: Optional[int] = None) -> Dict[str, Any]:
+        """Track a recommendation click"""
+        url = f"{self.base_url}/recommendations/click"
+        payload = {
+            "recommendation_id": recommendation_id,
+            "action_type": action_type
+        }
+        
+        if user_id:
+            payload["user_id"] = user_id
+            
+        response = requests.post(url, json=payload)
+        self.log_request_response("POST", url, payload=payload, response=response)
+        
+        self.assertEqual(response.status_code, 200, "Failed to track recommendation click")
+        return response.json()
+    
+    def enroll_in_campaign(self, campaign_id: int, user_data: Dict[str, Any]) -> Dict[str, Any]:
+        """Enroll in a campaign"""
+        url = f"{self.base_url}/banks/campaigns/{campaign_id}/enroll"
+        
+        response = requests.post(url, json=user_data)
+        self.log_request_response("POST", url, payload=user_data, response=response)
+        
+        # Note: This might return 400 if bank credentials aren't configured properly
+        return response.json()
+    
+    def test_full_user_flow(self):
+        """Test the full user flow from campaigns to recommendations to enrollment"""
+        if not self.api_available:
+            self.skipTest("API is not available - skipping integration test")
+        
+        # Step 1: Get all active campaigns
+        campaigns = self.get_campaigns()
+        self.assertTrue(len(campaigns) > 0, "No campaigns found")
+        
+        # Step 2: Get details for a specific campaign
+        campaign = campaigns[0]  # Use the first campaign
+        campaign_id = campaign["id"]
+        campaign_details = self.get_campaign_details(campaign_id)
+        
+        # Step 3: Get recommendations for a cart matching this campaign
+        # Extract campaign attributes to create matching cart data
+        merchant_name = campaign_details["merchant"]["name"]
+        category = campaign_details["category"]
+        min_amount = campaign_details["min_amount"] or 100
+        
+        cart_data = {
+            "cart_amount": min_amount * 2,  # Double the minimum for good measure
+            "cart_category": category,
+            "merchant_name": merchant_name
+        }
+        
+        recommendations = self.get_recommendations(cart_data)
+        self.assertTrue(
+            len(recommendations["existing_card_recommendations"]) > 0 or 
+            len(recommendations["new_card_recommendations"]) > 0,
+            "No recommendations returned"
+        )
+        
+        # Find a recommendation for our campaign
+        campaign_recommendation = None
+        if len(recommendations["existing_card_recommendations"]) > 0:
+            for rec in recommendations["existing_card_recommendations"]:
+                if rec["campaign_id"] == campaign_id:
+                    campaign_recommendation = rec
+                    break
+                    
+        if not campaign_recommendation and len(recommendations["new_card_recommendations"]) > 0:
+            for rec in recommendations["new_card_recommendations"]:
+                if rec["campaign_id"] == campaign_id:
+                    campaign_recommendation = rec
+                    break
+        
+        if not campaign_recommendation:
+            self.skipTest(f"No recommendation found for campaign {campaign_id}")
+        
+        # Step 4: Track a click on the recommendation
+        recommendation_id = campaign_recommendation["campaign_id"]
+        click_result = self.track_recommendation_click(recommendation_id)
+        self.assertTrue(click_result["success"], "Failed to track recommendation click")
+        
+        # Step 5: Try to enroll in the campaign if it requires enrollment
+        if campaign["requires_enrollment"]:
+            user_data = {
+                "masked_card_number": "1234",
+                "phone_number": "5551234567"
+            }
+            
+            try:
+                enrollment_result = self.enroll_in_campaign(campaign_id, user_data)
+                
+                if "detail" in enrollment_result:
+                    # Skip if we get an error about bank API credentials
+                    if "Bank API credentials" in enrollment_result["detail"]:
+                        print("INFO: Campaign enrollment would work with proper bank API credentials")
+                elif "success" in enrollment_result and enrollment_result["success"]:
+                    self.assertIn("enrollment_id", enrollment_result)
+                    print(f"Successfully enrolled in campaign {campaign_id}")
+            except Exception as e:
+                print(f"Enrollment attempt failed: {str(e)}")
+                    
+        # The test passes if we got this far
+        print(f"Successfully completed integration test for campaign {campaign_id}")
+        
+    def test_user_specific_recommendations(self):
+        """Test recommendations for a specific user with existing cards"""
+        if not self.api_available:
+            self.skipTest("API is not available - skipping integration test")
+        
+        # Use user ID 1 which should be created by the seed script
+        user_id = 1
+        
+        # Step 1: Get recommendations for a grocery purchase at Migros for a user
+        cart_data = {
+            "cart_amount": 500,
+            "cart_category": "grocery",
+            "merchant_name": "Migros",
+            "user_id": user_id
+        }
+        
+        recommendations = self.get_recommendations(cart_data)
+        
+        # Check if we got existing card recommendations
+        self.assertTrue(
+            len(recommendations["existing_card_recommendations"]) > 0,
+            "No existing card recommendations for user 1"
+        )
+        
+        # Track a click on the first recommendation
+        if len(recommendations["existing_card_recommendations"]) > 0:
+            recommendation = recommendations["existing_card_recommendations"][0]
+            recommendation_id = recommendation["campaign_id"]
+            
+            click_result = self.track_recommendation_click(
+                recommendation_id, 
+                action_type="select",
+                user_id=user_id
+            )
+            
+            self.assertTrue(click_result["success"], "Failed to track recommendation click")
+            print(f"Successfully tracked recommendation click for user {user_id}")
+        
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_recommendation_api.py b/app/tests/test_recommendation_api.py
new file mode 100644
index 0000000..34bfd4f
--- /dev/null
+++ b/app/tests/test_recommendation_api.py
@@ -0,0 +1,196 @@
+import unittest
+import requests
+import json
+from typing import Dict, Any
+
+BASE_URL = "http://localhost:8000/api/v1"
+
+class TestRecommendationAPI(unittest.TestCase):
+    def setUp(self):
+        self.base_url = BASE_URL
+        self.verbose = True  # Set to True to see request-response details
+        
+    def get_recommendations(self, cart_amount: float, cart_category: str, 
+                           merchant_name: str = None, user_id: int = None, 
+                           session_id: str = None) -> Dict[str, Any]:
+        """Get card recommendations based on cart data"""
+        url = f"{self.base_url}/recommendations/"
+        
+        payload = {
+            "cart_amount": cart_amount,
+            "cart_category": cart_category,
+            "merchant_name": merchant_name,
+            "user_id": user_id,
+            "session_id": session_id
+        }
+        
+        # Remove None values
+        payload = {k: v for k, v in payload.items() if v is not None}
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(payload, indent=2)}")
+        
+        response = requests.post(url, json=payload)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+
+    def track_recommendation_click(self, recommendation_id: int, action_type: str,
+                                  user_id: int = None, session_id: str = None) -> Dict[str, Any]:
+        """Track a click on a recommendation"""
+        url = f"{self.base_url}/recommendations/click"
+        
+        payload = {
+            "recommendation_id": recommendation_id,
+            "action_type": action_type,
+            "user_id": user_id,
+            "session_id": session_id
+        }
+        
+        # Remove None values
+        payload = {k: v for k, v in payload.items() if v is not None}
+        
+        if self.verbose:
+            print("\n=== REQUEST ===")
+            print(f"URL: {url}")
+            print(f"Method: POST")
+            print(f"Payload: {json.dumps(payload, indent=2)}")
+        
+        response = requests.post(url, json=payload)
+        
+        if self.verbose:
+            print("\n=== RESPONSE ===")
+            print(f"Status Code: {response.status_code}")
+            print(f"Response: {json.dumps(response.json(), indent=2)}")
+        
+        return response.json()
+    
+    def test_grocery_recommendation(self):
+        """Test recommendation for grocery shopping"""
+        result = self.get_recommendations(
+            cart_amount=500,
+            cart_category="grocery",
+            merchant_name="Migros",
+            user_id=1
+        )
+        
+        # Verify the API response structure
+        self.assertIn("request_id", result)
+        self.assertIn("cart_amount", result)
+        self.assertIn("cart_category", result)
+        
+        # Check if we have recommendations
+        existing_recs = result.get("existing_card_recommendations", [])
+        new_recs = result.get("new_card_recommendations", [])
+        
+        # Assert we have at least some recommendations
+        self.assertTrue(len(existing_recs) > 0 or len(new_recs) > 0, 
+                       "No recommendations returned for grocery category")
+        
+        # If there are recommendations, verify their structure and test clicking on one
+        recommendations = existing_recs + new_recs
+        
+        if recommendations:
+            rec = recommendations[0]
+            # Verify recommendation structure
+            self.assertIn("card_name", rec)
+            self.assertIn("bank_name", rec)
+            self.assertIn("discount_value", rec)
+            self.assertIn("savings_amount", rec)
+            
+            # Use campaign_id for the recommendation click tracking
+            # Since we don't have recommendation_id in the response
+            if "campaign_id" in rec:
+                click_result = self.track_recommendation_click(
+                    recommendation_id=rec["campaign_id"],
+                    action_type="select",
+                    user_id=1
+                )
+                self.assertIn("success", click_result)
+
+    def test_electronics_recommendation(self):
+        """Test recommendation for electronics shopping"""
+        result = self.get_recommendations(
+            cart_amount=2000,
+            cart_category="electronics",
+            merchant_name="Amazon"
+        )
+        
+        self.assertIn("request_id", result)
+        self.assertIn("cart_amount", result)
+        self.assertEqual(result["cart_amount"], 2000)
+        self.assertEqual(result["cart_category"], "electronics")
+        
+        # Check recommendations
+        existing_recs = result.get("existing_card_recommendations", [])
+        new_recs = result.get("new_card_recommendations", [])
+        
+        # Verify recommendations if any
+        recommendations = existing_recs + new_recs
+        if recommendations:
+            for rec in recommendations:
+                self.assertIn("discount_value", rec)
+                self.assertIn("savings_amount", rec)
+                self.assertIn("final_amount", rec)
+
+    def test_travel_recommendation(self):
+        """Test recommendation for travel purchase"""
+        result = self.get_recommendations(
+            cart_amount=5000,
+            cart_category="travel",
+            merchant_name="Turkish Airlines"
+        )
+        
+        self.assertIn("request_id", result)
+        self.assertIn("cart_amount", result)
+        self.assertEqual(result["cart_amount"], 5000)
+        self.assertEqual(result["cart_category"], "travel")
+        
+        # Check recommendations
+        existing_recs = result.get("existing_card_recommendations", [])
+        new_recs = result.get("new_card_recommendations", [])
+        
+        # Verify recommendations if any
+        recommendations = existing_recs + new_recs
+        if recommendations:
+            for rec in recommendations:
+                self.assertIn("card_name", rec)
+                self.assertIn("bank_name", rec)
+                self.assertIn("discount_type", rec)
+
+    def test_fuel_recommendation(self):
+        """Test recommendation for fuel purchase"""
+        result = self.get_recommendations(
+            cart_amount=300,
+            cart_category="fuel",
+            merchant_name="Shell"
+        )
+        
+        self.assertIn("request_id", result)
+        self.assertIn("cart_amount", result)
+        self.assertEqual(result["cart_amount"], 300)
+        self.assertEqual(result["cart_category"], "fuel")
+        
+        # Check recommendations
+        existing_recs = result.get("existing_card_recommendations", [])
+        new_recs = result.get("new_card_recommendations", [])
+        
+        # Verify recommendations if any
+        recommendations = existing_recs + new_recs
+        if recommendations:
+            for rec in recommendations:
+                self.assertIn("is_existing_card", rec)
+                if rec["is_existing_card"]:
+                    self.assertIn("card_name", rec)
+                else:
+                    self.assertIn("application_url", rec)
+
+if __name__ == "__main__":
+    unittest.main() 
\ No newline at end of file
diff --git a/app/tests/test_recommendation_service.py b/app/tests/test_recommendation_service.py
new file mode 100644
index 0000000..3c077d5
--- /dev/null
+++ b/app/tests/test_recommendation_service.py
@@ -0,0 +1,133 @@
+import unittest
+from datetime import datetime, timedelta
+from unittest.mock import Mock, patch
+
+from app.models.campaign import Campaign, CreditCard, Bank, CategoryEnum, DiscountType
+from app.models.user import User, Recommendation
+from app.schemas.recommendation import RecommendationRequest
+from app.services.recommendation_service import RecommendationService
+
+
+class TestRecommendationService(unittest.TestCase):
+    def setUp(self):
+        # Create a mock DB session
+        self.db = Mock()
+        
+        # Setup test data
+        self.bank = Bank(id=1, name="Test Bank", logo_url="http://example.com/logo.png")
+        self.card = CreditCard(
+            id=1, 
+            name="Test Card", 
+            bank_id=1, 
+            card_type="Visa", 
+            card_tier="Gold",
+            application_url="http://example.com/apply",
+            logo_url="http://example.com/card_logo.png"
+        )
+        
+        # Create a test campaign
+        now = datetime.now()
+        self.campaign = Campaign(
+            id=1,
+            name="Test Campaign",
+            bank_id=1,
+            card_id=1,
+            category=CategoryEnum.ELECTRONICS,
+            discount_type=DiscountType.PERCENTAGE,
+            discount_value=10.0,
+            min_amount=100.0,
+            max_discount=50.0,
+            start_date=now,
+            end_date=now + timedelta(days=30),
+            is_active=True,
+            requires_enrollment=False
+        )
+        
+        # Setup relationships
+        self.campaign.bank = self.bank
+        self.campaign.credit_card = self.card
+        
+        # Setup service
+        self.service = RecommendationService(self.db)
+
+    def test_calculate_savings_percentage(self):
+        # Test percentage discount
+        self.campaign.discount_type = DiscountType.PERCENTAGE
+        self.campaign.discount_value = 10.0
+        self.campaign.max_discount = 50.0
+        
+        # Test with amount under max discount cap
+        result = self.service.calculate_savings(self.campaign, 200.0)
+        self.assertEqual(result["savings_amount"], 20.0)
+        self.assertEqual(result["final_amount"], 180.0)
+        
+        # Test with amount that exceeds max discount cap
+        result = self.service.calculate_savings(self.campaign, 1000.0)
+        self.assertEqual(result["savings_amount"], 50.0)  # Capped at max_discount
+        self.assertEqual(result["final_amount"], 950.0)
+
+    def test_calculate_savings_cashback(self):
+        # Test cashback
+        self.campaign.discount_type = DiscountType.CASHBACK
+        self.campaign.discount_value = 30.0
+        
+        result = self.service.calculate_savings(self.campaign, 200.0)
+        self.assertEqual(result["savings_amount"], 30.0)
+        self.assertEqual(result["final_amount"], 200.0)  # Cashback doesn't change final amount
+
+    def test_find_matching_campaigns(self):
+        # Setup mock query and results
+        mock_query = Mock()
+        self.db.query.return_value = mock_query
+        mock_query.filter.return_value = mock_query
+        mock_query.all.return_value = [self.campaign]
+        
+        # Test finding campaigns
+        result = self.service.find_matching_campaigns(200.0, "electronics")
+        
+        # Verify query was called
+        self.db.query.assert_called_once()
+        self.assertEqual(result, [self.campaign])
+
+    @patch('app.services.recommendation_service.uuid.uuid4')
+    def test_get_recommendations(self, mock_uuid):
+        # Mock UUID
+        mock_uuid.return_value = "test-uuid"
+        
+        # Setup mocks for find_matching_campaigns
+        self.service.find_matching_campaigns = Mock(return_value=[self.campaign])
+        
+        # Mock DB operation for storing recommendations
+        self.service._store_recommendations = Mock()
+        
+        # Create test request
+        request = RecommendationRequest(
+            cart_amount=200.0,
+            cart_category="electronics",
+            user_cards=[2, 3]  # Not including our test card (id=1)
+        )
+        
+        # Get recommendations
+        response = self.service.get_recommendations(request)
+        
+        # Verify results
+        self.assertEqual(response.request_id, "test-uuid")
+        self.assertEqual(response.cart_amount, 200.0)
+        self.assertEqual(response.cart_category, "electronics")
+        
+        # Should be in new card recommendations (not existing)
+        self.assertEqual(len(response.existing_card_recommendations), 0)
+        self.assertEqual(len(response.new_card_recommendations), 1)
+        
+        # Verify card details
+        card_rec = response.new_card_recommendations[0]
+        self.assertEqual(card_rec.card_name, "Test Card")
+        self.assertEqual(card_rec.bank_name, "Test Bank")
+        self.assertEqual(card_rec.discount_value, 10.0)
+        self.assertEqual(card_rec.savings_amount, 20.0)
+        self.assertEqual(card_rec.final_amount, 180.0)
+        self.assertFalse(card_rec.is_existing_card)
+
+
+if __name__ == '__main__':
+    unittest.main() 
\ No newline at end of file
diff --git a/app/utils/__init__.py b/app/utils/__init__.py
new file mode 100644
index 0000000..620e123
--- /dev/null
+++ b/app/utils/__init__.py
@@ -0,0 +1 @@
+# Utils module initialization 
\ No newline at end of file
diff --git a/app/utils/crypto.py b/app/utils/crypto.py
new file mode 100644
index 0000000..92ea7eb
--- /dev/null
+++ b/app/utils/crypto.py
@@ -0,0 +1,40 @@
+import base64
+import os
+from cryptography.fernet import Fernet
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+
+from app.core.config import settings
+
+# Create a key from the secret key
+def get_encryption_key():
+    """Generate an encryption key from the app secret key"""
+    salt = b'payviya_salt'  # This would ideally be stored securely
+    kdf = PBKDF2HMAC(
+        algorithm=hashes.SHA256(),
+        length=32,
+        salt=salt,
+        iterations=100000,
+    )
+    key = base64.urlsafe_b64encode(kdf.derive(settings.SECRET_KEY.encode()))
+    return key
+
+def encrypt_data(data: str) -> str:
+    """Encrypt sensitive data"""
+    if not data:
+        return None
+        
+    key = get_encryption_key()
+    f = Fernet(key)
+    encrypted_data = f.encrypt(data.encode())
+    return base64.urlsafe_b64encode(encrypted_data).decode()
+
+def decrypt_data(data: str) -> str:
+    """Decrypt sensitive data"""
+    if not data:
+        return None
+        
+    key = get_encryption_key()
+    f = Fernet(key)
+    encrypted_data = base64.urlsafe_b64decode(data.encode())
+    return f.decrypt(encrypted_data).decode() 
\ No newline at end of file
diff --git a/flutter_app/assets/images/avatar.png b/flutter_app/assets/images/avatar.png
new file mode 100644
index 0000000..e69de29
diff --git a/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/_composite.stamp b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/_composite.stamp
new file mode 100644
index 0000000..1b2d28c
--- /dev/null
+++ b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/_composite.stamp
@@ -0,0 +1 @@
+{"inputs":[],"outputs":[]}
\ No newline at end of file
diff --git a/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_dart_plugin_registrant.stamp b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_dart_plugin_registrant.stamp
new file mode 100644
index 0000000..1b2d28c
--- /dev/null
+++ b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_dart_plugin_registrant.stamp
@@ -0,0 +1 @@
+{"inputs":[],"outputs":[]}
\ No newline at end of file
diff --git a/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_localizations.stamp b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_localizations.stamp
new file mode 100644
index 0000000..1b2d28c
--- /dev/null
+++ b/flutter_app/build/705d0a760af64a5c3d9fea60f560ff7e/gen_localizations.stamp
@@ -0,0 +1 @@
+{"inputs":[],"outputs":[]}
\ No newline at end of file
diff --git a/flutter_app/build/cache.dill.track.dill b/flutter_app/build/cache.dill.track.dill
index d806a44..04ccc9e 100644
Binary files a/flutter_app/build/cache.dill.track.dill and b/flutter_app/build/cache.dill.track.dill differ
diff --git a/flutter_app/build/flutter_assets/AssetManifest.bin b/flutter_app/build/flutter_assets/AssetManifest.bin
index aa51c38..b14ccc5 100644
--- a/flutter_app/build/flutter_assets/AssetManifest.bin
+++ b/flutter_app/build/flutter_assets/AssetManifest.bin
@@ -1 +1 @@
-assets/fonts/Roboto-Bold.ttfassetassets/fonts/Roboto-Bold.ttfassets/fonts/Roboto-Medium.ttfassetassets/fonts/Roboto-Medium.ttfassets/fonts/Roboto-Regular.ttfassetassets/fonts/Roboto-Regular.ttfassets/icons/placeholder.svgassetassets/icons/placeholder.svgassets/images/placeholder.pngassetassets/images/placeholder.png2packages/cupertino_icons/assets/CupertinoIcons.ttfasset2packages/cupertino_icons/assets/CupertinoIcons.ttf
\ No newline at end of file
+assets/fonts/Roboto-Bold.ttfassetassets/fonts/Roboto-Bold.ttfassets/fonts/Roboto-Medium.ttfassetassets/fonts/Roboto-Medium.ttfassets/fonts/Roboto-Regular.ttfassetassets/fonts/Roboto-Regular.ttfassets/icons/placeholder.svgassetassets/icons/placeholder.svgassets/images/avatar.pngassetassets/images/avatar.pngassets/images/placeholder.pngassetassets/images/placeholder.png2packages/cupertino_icons/assets/CupertinoIcons.ttfasset2packages/cupertino_icons/assets/CupertinoIcons.ttf
\ No newline at end of file
diff --git a/flutter_app/build/flutter_assets/AssetManifest.bin.json b/flutter_app/build/flutter_assets/AssetManifest.bin.json
index 683f887..58e3360 100644
--- a/flutter_app/build/flutter_assets/AssetManifest.bin.json
+++ b/flutter_app/build/flutter_assets/AssetManifest.bin.json
@@ -1 +1 @@
-"DQYHHGFzc2V0cy9mb250cy9Sb2JvdG8tQm9sZC50dGYMAQ0BBwVhc3NldAccYXNzZXRzL2ZvbnRzL1JvYm90by1Cb2xkLnR0ZgceYXNzZXRzL2ZvbnRzL1JvYm90by1NZWRpdW0udHRmDAENAQcFYXNzZXQHHmFzc2V0cy9mb250cy9Sb2JvdG8tTWVkaXVtLnR0ZgcfYXNzZXRzL2ZvbnRzL1JvYm90by1SZWd1bGFyLnR0ZgwBDQEHBWFzc2V0Bx9hc3NldHMvZm9udHMvUm9ib3RvLVJlZ3VsYXIudHRmBxxhc3NldHMvaWNvbnMvcGxhY2Vob2xkZXIuc3ZnDAENAQcFYXNzZXQHHGFzc2V0cy9pY29ucy9wbGFjZWhvbGRlci5zdmcHHWFzc2V0cy9pbWFnZXMvcGxhY2Vob2xkZXIucG5nDAENAQcFYXNzZXQHHWFzc2V0cy9pbWFnZXMvcGxhY2Vob2xkZXIucG5nBzJwYWNrYWdlcy9jdXBlcnRpbm9faWNvbnMvYXNzZXRzL0N1cGVydGlub0ljb25zLnR0ZgwBDQEHBWFzc2V0BzJwYWNrYWdlcy9jdXBlcnRpbm9faWNvbnMvYXNzZXRzL0N1cGVydGlub0ljb25zLnR0Zg=="
\ No newline at end of file
+"DQcHHGFzc2V0cy9mb250cy9Sb2JvdG8tQm9sZC50dGYMAQ0BBwVhc3NldAccYXNzZXRzL2ZvbnRzL1JvYm90by1Cb2xkLnR0ZgceYXNzZXRzL2ZvbnRzL1JvYm90by1NZWRpdW0udHRmDAENAQcFYXNzZXQHHmFzc2V0cy9mb250cy9Sb2JvdG8tTWVkaXVtLnR0ZgcfYXNzZXRzL2ZvbnRzL1JvYm90by1SZWd1bGFyLnR0ZgwBDQEHBWFzc2V0Bx9hc3NldHMvZm9udHMvUm9ib3RvLVJlZ3VsYXIudHRmBxxhc3NldHMvaWNvbnMvcGxhY2Vob2xkZXIuc3ZnDAENAQcFYXNzZXQHHGFzc2V0cy9pY29ucy9wbGFjZWhvbGRlci5zdmcHGGFzc2V0cy9pbWFnZXMvYXZhdGFyLnBuZwwBDQEHBWFzc2V0Bxhhc3NldHMvaW1hZ2VzL2F2YXRhci5wbmcHHWFzc2V0cy9pbWFnZXMvcGxhY2Vob2xkZXIucG5nDAENAQcFYXNzZXQHHWFzc2V0cy9pbWFnZXMvcGxhY2Vob2xkZXIucG5nBzJwYWNrYWdlcy9jdXBlcnRpbm9faWNvbnMvYXNzZXRzL0N1cGVydGlub0ljb25zLnR0ZgwBDQEHBWFzc2V0BzJwYWNrYWdlcy9jdXBlcnRpbm9faWNvbnMvYXNzZXRzL0N1cGVydGlub0ljb25zLnR0Zg=="
\ No newline at end of file
diff --git a/flutter_app/build/flutter_assets/AssetManifest.json b/flutter_app/build/flutter_assets/AssetManifest.json
index 31e0312..964dc47 100644
--- a/flutter_app/build/flutter_assets/AssetManifest.json
+++ b/flutter_app/build/flutter_assets/AssetManifest.json
@@ -1 +1 @@
-{"assets/fonts/Roboto-Bold.ttf":["assets/fonts/Roboto-Bold.ttf"],"assets/fonts/Roboto-Medium.ttf":["assets/fonts/Roboto-Medium.ttf"],"assets/fonts/Roboto-Regular.ttf":["assets/fonts/Roboto-Regular.ttf"],"assets/icons/placeholder.svg":["assets/icons/placeholder.svg"],"assets/images/placeholder.png":["assets/images/placeholder.png"],"packages/cupertino_icons/assets/CupertinoIcons.ttf":["packages/cupertino_icons/assets/CupertinoIcons.ttf"]}
\ No newline at end of file
+{"assets/fonts/Roboto-Bold.ttf":["assets/fonts/Roboto-Bold.ttf"],"assets/fonts/Roboto-Medium.ttf":["assets/fonts/Roboto-Medium.ttf"],"assets/fonts/Roboto-Regular.ttf":["assets/fonts/Roboto-Regular.ttf"],"assets/icons/placeholder.svg":["assets/icons/placeholder.svg"],"assets/images/avatar.png":["assets/images/avatar.png"],"assets/images/placeholder.png":["assets/images/placeholder.png"],"packages/cupertino_icons/assets/CupertinoIcons.ttf":["packages/cupertino_icons/assets/CupertinoIcons.ttf"]}
\ No newline at end of file
diff --git a/flutter_app/build/flutter_assets/FontManifest.json b/flutter_app/build/flutter_assets/FontManifest.json
index 4e10f37..3cd47a0 100644
--- a/flutter_app/build/flutter_assets/FontManifest.json
+++ b/flutter_app/build/flutter_assets/FontManifest.json
@@ -1 +1 @@
-[{"family":"MaterialIcons","fonts":[{"asset":"fonts/MaterialIcons-Regular.otf"}]},{"family":"Roboto","fonts":[{"asset":"assets/fonts/Roboto-Regular.ttf"},{"weight":500,"asset":"assets/fonts/Roboto-Medium.ttf"},{"weight":700,"asset":"assets/fonts/Roboto-Bold.ttf"}]},{"family":"packages/cupertino_icons/CupertinoIcons","fonts":[{"asset":"packages/cupertino_icons/assets/CupertinoIcons.ttf"}]}]
\ No newline at end of file
+[{"family":"MaterialIcons","fonts":[{"asset":"fonts/MaterialIcons-Regular.otf"}]},{"family":"Roboto","fonts":[{"weight":400,"asset":"assets/fonts/Roboto-Regular.ttf"},{"weight":500,"asset":"assets/fonts/Roboto-Medium.ttf"},{"weight":700,"asset":"assets/fonts/Roboto-Bold.ttf"}]},{"family":"packages/cupertino_icons/CupertinoIcons","fonts":[{"asset":"packages/cupertino_icons/assets/CupertinoIcons.ttf"}]}]
\ No newline at end of file
diff --git a/flutter_app/build/flutter_assets/NOTICES b/flutter_app/build/flutter_assets/NOTICES
index 9eb5c31..6958ba9 100644
--- a/flutter_app/build/flutter_assets/NOTICES
+++ b/flutter_app/build/flutter_assets/NOTICES
@@ -30502,6 +30502,16 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+--------------------------------------------------------------------------------
+jwt_decoder
+
+Copyright 2020 Gustavo Velazquez
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 --------------------------------------------------------------------------------
 khronos
 
diff --git a/flutter_app/build/flutter_assets/assets/images/avatar.png b/flutter_app/build/flutter_assets/assets/images/avatar.png
new file mode 100644
index 0000000..e69de29
diff --git a/flutter_app/lib/core/theme/app_theme.dart b/flutter_app/lib/core/theme/app_theme.dart
index 1814a34..67e77ad 100644
--- a/flutter_app/lib/core/theme/app_theme.dart
+++ b/flutter_app/lib/core/theme/app_theme.dart
@@ -36,7 +36,7 @@ class AppTheme {
   static const Color darkDividerColor = Color(0xFF2C2C2C);
 
   // Font families with fallbacks to ensure text always displays
-  static const String primaryFontFamily = 'Roboto, Arial, Helvetica, sans-serif';
+  static const String primaryFontFamily = 'Roboto';
   
   // Text styles with fallback fonts
   static TextStyle get headingStyle => const TextStyle(
@@ -117,7 +117,7 @@ class AppTheme {
       surface: cardColor,
     ),
     scaffoldBackgroundColor: backgroundColor, // Ensures white background
-    fontFamily: 'Roboto, sans-serif', // Fallback added
+    fontFamily: 'Roboto', // Simple font family name without any commas or fallbacks
     appBarTheme: const AppBarTheme(
       elevation: 0,
       backgroundColor: Colors.white, // White app bar
@@ -196,7 +196,7 @@ class AppTheme {
       surface: darkCardColor,
     ),
     scaffoldBackgroundColor: darkBackgroundColor,
-    fontFamily: 'Roboto, sans-serif', // Fallback added
+    fontFamily: 'Roboto', // Simple font family name without any commas or fallbacks
     appBarTheme: const AppBarTheme(
       elevation: 0,
       backgroundColor: darkCardColor,
diff --git a/flutter_app/lib/models/campaign.dart b/flutter_app/lib/models/campaign.dart
index 82b610b..2ba8656 100644
--- a/flutter_app/lib/models/campaign.dart
+++ b/flutter_app/lib/models/campaign.dart
@@ -90,33 +90,45 @@ class Campaign {
   });
   
   factory Campaign.fromJson(Map<String, dynamic> json) {
+    // Handle potential nulls and different data types
+    
+    // Special handling for source field to match enum values in server
+    String sourceValue = json['source'] ?? 'MANUAL';
+    // Keep uppercase - the API now uses uppercase enum values
+    
     return Campaign(
       id: json['id'],
-      name: json['name'],
+      name: json['name'] ?? 'Unnamed Campaign',
       description: json['description'] ?? '',
-      bankId: json['bank_id'],
-      cardId: json['card_id'],
-      category: json['category'],
-      discountType: json['discount_type'],
-      discountValue: json['discount_value'].toDouble(),
-      minAmount: json['min_amount']?.toDouble() ?? 0,
-      maxDiscount: json['max_discount']?.toDouble(),
-      startDate: DateTime.parse(json['start_date']),
-      endDate: DateTime.parse(json['end_date']),
+      bankId: json['bank_id'] ?? 0,
+      cardId: json['card_id'] ?? 0,
+      category: json['category'] ?? 'Uncategorized',
+      discountType: json['discount_type'] ?? 'other',
+      discountValue: (json['discount_value'] ?? 0).toDouble(),
+      minAmount: (json['min_amount'] ?? 0).toDouble(),
+      maxDiscount: json['max_discount'] != null ? (json['max_discount']).toDouble() : null,
+      startDate: json['start_date'] != null 
+          ? DateTime.parse(json['start_date'])
+          : DateTime.now(),
+      endDate: json['end_date'] != null
+          ? DateTime.parse(json['end_date'])
+          : DateTime.now().add(const Duration(days: 30)),
       merchantId: json['merchant_id'],
       isActive: json['is_active'] ?? true,
       requiresEnrollment: json['requires_enrollment'] ?? false,
       enrollmentUrl: json['enrollment_url'],
-      source: json['source'] ?? 'manual',
+      source: sourceValue,
       status: json['status'] ?? 'approved',
-      externalId: json['external_id'],
+      externalId: json['external_id']?.toString(),
       priority: json['priority'] ?? 0,
       lastSyncAt: json['last_sync_at'] != null 
           ? DateTime.parse(json['last_sync_at'])
           : null,
       reviewNotes: json['review_notes'],
       reviewedBy: json['reviewed_by'],
-      createdAt: DateTime.parse(json['created_at']),
+      createdAt: json['created_at'] != null
+          ? DateTime.parse(json['created_at'])
+          : DateTime.now(),
       updatedAt: json['updated_at'] != null 
           ? DateTime.parse(json['updated_at'])
           : null,
@@ -144,8 +156,8 @@ class Bank {
   
   factory Bank.fromJson(Map<String, dynamic> json) {
     return Bank(
-      id: json['id'],
-      name: json['name'],
+      id: json['id'] ?? 0,
+      name: json['name'] ?? 'Unknown Bank',
       logoUrl: json['logo_url'],
     );
   }
@@ -180,13 +192,13 @@ class CreditCard {
   
   factory CreditCard.fromJson(Map<String, dynamic> json) {
     return CreditCard(
-      id: json['id'],
-      name: json['name'],
-      bankId: json['bank_id'],
-      cardType: json['card_type'],
-      cardTier: json['card_tier'],
-      annualFee: json['annual_fee']?.toDouble(),
-      rewardsRate: json['rewards_rate']?.toDouble(),
+      id: json['id'] ?? 0,
+      name: json['name'] ?? 'Unknown Card',
+      bankId: json['bank_id'] ?? 0,
+      cardType: json['card_type'] ?? 'unknown',
+      cardTier: json['card_tier'] ?? 'standard',
+      annualFee: json['annual_fee'] != null ? (json['annual_fee']).toDouble() : null,
+      rewardsRate: json['rewards_rate'] != null ? (json['rewards_rate']).toDouble() : null,
       applicationUrl: json['application_url'],
       affiliateCode: json['affiliate_code'],
       logoUrl: json['logo_url'],
@@ -210,9 +222,9 @@ class Merchant {
   
   factory Merchant.fromJson(Map<String, dynamic> json) {
     return Merchant(
-      id: json['id'],
-      name: json['name'],
-      categories: json['categories'],
+      id: json['id'] ?? 0,
+      name: json['name'] ?? 'Unknown Merchant',
+      categories: json['categories'] ?? '',
       logoUrl: json['logo_url'],
     );
   }
diff --git a/flutter_app/lib/screens/dashboard/tabs/home_tab.dart b/flutter_app/lib/screens/dashboard/tabs/home_tab.dart
index 4b0f832..be582a2 100644
--- a/flutter_app/lib/screens/dashboard/tabs/home_tab.dart
+++ b/flutter_app/lib/screens/dashboard/tabs/home_tab.dart
@@ -1,7 +1,14 @@
 import 'package:flutter/material.dart';
 import 'package:payviya_app/core/theme/app_theme.dart';
+import 'package:payviya_app/models/campaign.dart';
+import 'package:payviya_app/services/campaign_service.dart';
+import 'package:payviya_app/services/user_service.dart';
 import 'package:payviya_app/widgets/campaign_card.dart';
+import 'package:payviya_app/widgets/loading_indicator.dart';
+import 'package:payviya_app/widgets/error_indicator.dart';
 import 'package:payviya_app/widgets/savings_chart.dart';
+import 'package:payviya_app/widgets/dashboard_card.dart';
+import 'package:payviya_app/services/api_service.dart';
 
 class HomeTab extends StatefulWidget {
   const HomeTab({Key? key}) : super(key: key);
@@ -11,190 +18,377 @@ class HomeTab extends StatefulWidget {
 }
 
 class _HomeTabState extends State<HomeTab> {
-  // Mock data
-  final bool _hasCards = true; // Mock flag to determine if user has saved cards
+  bool _isLoading = true;
+  bool _hasError = false;
+  String? _errorMessage = '';
+  String _userName = '';
   
-  final Map<String, dynamic> _lastCaughtCampaign = {
-    'id': 1,
-    'bankName': 'TürkBank',
-    'cardName': 'Cash Rewards Platinum',
-    'discount': '15%',
-    'category': 'Groceries',
-    'expiry': '31 Aralık 2023',
-    'logoUrl': 'assets/images/bank1.png',
-    'color': const Color(0xFF3A86FF),
-    'timestamp': '2 saat önce',
+  // Campaign data
+  List<Campaign> _recentCampaigns = [];
+  List<Campaign> _recommendedCampaigns = [];
+  Map<String, List<Campaign>> _campaignsByCategory = {};
+  Map<String, dynamic> _campaignStats = {
+    'total': 0,
+    'active': 0,
+    'expiring_soon': 0,
   };
+  Campaign? _lastCapturedCampaign;
+  List<String> _categories = [];
   
-  final Map<String, dynamic> _bestRecommendation = {
-    'id': 2,
-    'bankName': 'FinansBank',
-    'cardName': 'Shopping Card',
-    'discount': '25%',
-    'category': 'Electronics',
-    'expiry': '15 Kasım 2023',
-    'logoUrl': 'assets/images/bank2.png',
-    'color': const Color(0xFF9D4EDD),
-  };
-  
-  final Map<String, dynamic> _bestCampaign = {
-    'id': 3,
-    'bankName': 'DigiBank',
-    'cardName': 'Max Rewards',
-    'discount': '30%',
-    'category': 'Restaurants',
-    'expiry': '10 Aralık 2023',
-    'logoUrl': 'assets/images/bank3.png',
-    'color': const Color(0xFF5E60CE),
-  };
-  
-  final List<Map<String, dynamic>> _todaysCampaigns = [
-    {
-      'id': 4,
-      'bankName': 'AkBank',
-      'cardName': 'Wings Kart',
-      'discount': '10%',
-      'category': 'Travel',
-      'expiry': '1 Ocak 2024',
-      'logoUrl': 'assets/images/bank4.png',
-      'color': const Color(0xFF72DDF7),
-    },
-    {
-      'id': 5,
-      'bankName': 'YapıKredi',
-      'cardName': 'World Elite',
-      'discount': '150 TL',
-      'category': 'Fashion',
-      'expiry': '5 Aralık 2023',
-      'logoUrl': 'assets/images/bank5.png',
-      'color': const Color(0xFFF8961E),
-    },
-  ];
-
   // Total campaign count
   final int _totalCampaignCount = 35;
+  
+  @override
+  void initState() {
+    super.initState();
+    _loadDashboardData();
+  }
+  
+  Future<void> _loadDashboardData() async {
+    setState(() {
+      _isLoading = true;
+      _hasError = false;
+    });
+    
+    try {
+      // Get user profile
+      final userData = await UserService.getCurrentUser();
+      // Just use the name property since full_name doesn't exist
+      _userName = userData?.name ?? 'User';
+      
+      // Get campaign data
+      try {
+        final campaignData = await CampaignService.getDashboardCampaigns();
+        _recentCampaigns = campaignData['recent'] as List<Campaign>;
+        _recommendedCampaigns = campaignData['recommended'] as List<Campaign>;
+        _campaignsByCategory = campaignData['by_category'] as Map<String, List<Campaign>>;
+      } catch (e) {
+        print('Error loading campaign data: $e');
+        // Reset campaign data
+        _recentCampaigns = [];
+        _recommendedCampaigns = [];
+        _campaignsByCategory = {};
+      }
+      
+      // Get campaign stats - each API call in its own try/catch
+      try {
+        _campaignStats = await CampaignService.getCampaignStats();
+      } catch (e) {
+        print('Error loading campaign stats: $e');
+        _campaignStats = {
+          'total': 0,
+          'active': 0,
+          'expiring_soon': 0,
+        };
+      }
+      
+      // Get last captured campaign
+      try {
+        _lastCapturedCampaign = await CampaignService.getLastCapturedCampaign();
+      } catch (e) {
+        print('Error loading last captured campaign: $e');
+        _lastCapturedCampaign = null;
+      }
+      
+      // Get campaign categories
+      try {
+        _categories = await CampaignService.getCampaignCategories();
+      } catch (e) {
+        print('Error loading campaign categories: $e');
+        _categories = [];
+      }
+      
+      if (mounted) {
+        setState(() {
+          _isLoading = false;
+        });
+      }
+    } catch (e) {
+      if (mounted) {
+        setState(() {
+          _hasError = true;
+          _errorMessage = 'Failed to load data: ${e.toString()}';
+          _isLoading = false;
+        });
+      }
+    }
+  }
 
   @override
   Widget build(BuildContext context) {
     return Scaffold(
       backgroundColor: Colors.white,
       body: SafeArea(
-        child: CustomScrollView(
-          slivers: [
-            // App Bar
-            SliverAppBar(
-              automaticallyImplyLeading: false,
-              floating: true,
-              pinned: false,
-              snap: false,
-              backgroundColor: Colors.white,
-              elevation: 0,
-              title: const Row(
-                children: [
-                  CircleAvatar(
-                    backgroundColor: AppTheme.primaryColor,
-                    radius: 18,
-                    child: Text(
-                      "C",
-                      style: TextStyle(
-                        color: Colors.white,
-                        fontWeight: FontWeight.bold,
+        child: _isLoading 
+          ? const Center(child: LoadingIndicator())
+          : _hasError 
+              ? _buildErrorIndicator()
+              : RefreshIndicator(
+                  onRefresh: _loadDashboardData,
+                  child: _buildDashboardContent(),
+                ),
+      ),
+    );
+  }
+  
+  Widget _buildDashboardContent() {
+    return CustomScrollView(
+      slivers: [
+        // App Bar
+        SliverAppBar(
+          automaticallyImplyLeading: false,
+          floating: true,
+          pinned: false,
+          snap: false,
+          backgroundColor: Colors.white,
+          elevation: 0,
+          title: Row(
+            children: [
+              CircleAvatar(
+                backgroundColor: AppTheme.primaryColor,
+                radius: 18,
+                child: Text(
+                  _userName.isNotEmpty ? _userName[0].toUpperCase() : "U",
+                  style: const TextStyle(
+                    color: Colors.white,
+                    fontWeight: FontWeight.bold,
+                  ),
+                ),
+              ),
+              const SizedBox(width: 12),
+              Text(
+                "Merhaba, $_userName",
+                style: const TextStyle(
+                  color: AppTheme.textPrimaryColor,
+                  fontSize: 18,
+                  fontWeight: FontWeight.w500,
+                ),
+              ),
+            ],
+          ),
+          actions: [
+            IconButton(
+              icon: const Icon(
+                Icons.notifications_outlined,
+                color: AppTheme.textPrimaryColor,
+              ),
+              onPressed: () {
+                // Navigate to notifications
+              },
+            ),
+          ],
+        ),
+        
+        // Content
+        SliverToBoxAdapter(
+          child: Padding(
+            padding: const EdgeInsets.symmetric(horizontal: 16),
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                const SizedBox(height: 16),
+                
+                // 1. Last captured campaign - only show if not null
+                if (_lastCapturedCampaign != null) 
+                  _buildLastCaughtCampaign(),
+                
+                // 2. Campaign stats
+                _buildCampaignStats(),
+                
+                // 3. Recommended campaigns
+                if (_recommendedCampaigns.isNotEmpty) ...[
+                  DashboardCard(
+                    title: 'Sizin İçin Öneriler',
+                    trailing: const Icon(
+                      Icons.recommend,
+                      color: AppTheme.primaryColor,
+                    ),
+                    child: SizedBox(
+                      height: 180,
+                      child: ListView.builder(
+                        scrollDirection: Axis.horizontal,
+                        itemCount: _recommendedCampaigns.length,
+                        itemBuilder: (context, index) {
+                          final campaign = _recommendedCampaigns[index];
+                          return Padding(
+                            padding: EdgeInsets.only(
+                              right: index < _recommendedCampaigns.length - 1 ? 12 : 0,
+                            ),
+                            child: CampaignCard(
+                              bankName: campaign.bank?.name ?? 'Bank',
+                              cardName: campaign.creditCard?.name ?? 'Card',
+                              discount: campaign.formattedDiscount,
+                              category: campaign.category,
+                              expiry: campaign.timeRemaining,
+                              color: _getColorForIndex(index),
+                              width: 280,
+                              onTap: () {
+                                // Navigate to campaign detail
+                              },
+                            ),
+                          );
+                        },
                       ),
                     ),
                   ),
-                  SizedBox(width: 12),
-                  Text(
-                    "Merhaba, Ceyhun",
-                    style: TextStyle(
-                      color: AppTheme.textPrimaryColor,
-                      fontSize: 18,
-                      fontWeight: FontWeight.w500,
+                ],
+                
+                // 4. Recent campaigns
+                if (_recentCampaigns.isNotEmpty) ...[
+                  DashboardCard(
+                    title: 'Yeni Eklenen Kampanyalar',
+                    trailing: const Icon(
+                      Icons.new_releases_outlined,
+                      color: AppTheme.primaryColor,
+                    ),
+                    child: SizedBox(
+                      height: 180,
+                      child: ListView.builder(
+                        scrollDirection: Axis.horizontal,
+                        itemCount: _recentCampaigns.length,
+                        itemBuilder: (context, index) {
+                          final campaign = _recentCampaigns[index];
+                          return Padding(
+                            padding: EdgeInsets.only(
+                              right: index < _recentCampaigns.length - 1 ? 12 : 0,
+                            ),
+                            child: CampaignCard(
+                              bankName: campaign.bank?.name ?? 'Bank',
+                              cardName: campaign.creditCard?.name ?? 'Card',
+                              discount: campaign.formattedDiscount,
+                              category: campaign.category,
+                              expiry: campaign.timeRemaining,
+                              color: _getColorForIndex(index),
+                              width: 280,
+                              onTap: () {
+                                // Navigate to campaign detail
+                              },
+                            ),
+                          );
+                        },
+                      ),
                     ),
                   ),
                 ],
-              ),
-              actions: [
-                IconButton(
-                  icon: const Icon(
-                    Icons.notifications_outlined,
-                    color: AppTheme.textPrimaryColor,
-                  ),
-                  onPressed: () {
-                    // Navigate to notifications
-                  },
-                ),
+                
+                // 5. Campaigns by category
+                if (_campaignsByCategory.isNotEmpty) ...[
+                  _buildCategoryCampaigns(),
+                ],
+                
+                const SizedBox(height: 32),
               ],
             ),
-            
-            // Content
-            SliverToBoxAdapter(
-              child: Padding(
-                padding: const EdgeInsets.symmetric(horizontal: 16),
-                child: Column(
-                  crossAxisAlignment: CrossAxisAlignment.start,
-                  children: [
-                    const SizedBox(height: 16),
-                    
-                    // 1. Last caught campaign (En son yakalanan kampanya)
-                    _buildSectionTitle('En Son Yakalanan Kampanya'),
-                    _buildLastCaughtCampaign(),
-                    
-                    const SizedBox(height: 24),
-                    
-                    // 2. Total campaign count info
-                    _buildTotalCampaignInfo(),
-                    
-                    const SizedBox(height: 24),
-                    
-                    // 3. Best campaign/Best recommendation (En iyi teklif) 
-                    _buildSectionTitle('En İyi Teklif'),
-                    _buildBestOffer(),
-                    
-                    const SizedBox(height: 24),
-                    
-                    // 4. Today's campaigns (Bugünkü Fırsatlar)
-                    _buildSectionTitle('Bugünkü Fırsatlar'),
-                    _buildTodaysCampaigns(),
-                    
-                    const SizedBox(height: 32),
-                  ],
-                ),
-              ),
-            ),
-          ],
+          ),
         ),
-      ),
+      ],
     );
   }
   
-  Widget _buildSectionTitle(String title) {
-    return Padding(
-      padding: const EdgeInsets.only(bottom: 16),
-      child: Row(
-        mainAxisAlignment: MainAxisAlignment.spaceBetween,
-        children: [
-          Text(
-            title,
-            style: const TextStyle(
-              fontSize: 18,
-              fontWeight: FontWeight.bold,
-              color: AppTheme.textPrimaryColor,
+  Widget _buildLastCaughtCampaign() {
+    if (_isLoading) {
+      return Container(
+        height: 200,
+        decoration: BoxDecoration(
+          color: Colors.white,
+          borderRadius: BorderRadius.circular(16),
+          boxShadow: [
+            BoxShadow(
+              color: Colors.black.withOpacity(0.04),
+              blurRadius: 10,
+              offset: const Offset(0, 4),
+            ),
+          ],
+        ),
+        child: const Center(
+          child: CircularProgressIndicator(),
+        ),
+      );
+    }
+    
+    if (_errorMessage != null) {
+      return Container(
+        height: 150,
+        decoration: BoxDecoration(
+          color: Colors.white,
+          borderRadius: BorderRadius.circular(16),
+          boxShadow: [
+            BoxShadow(
+              color: Colors.black.withOpacity(0.04),
+              blurRadius: 10,
+              offset: const Offset(0, 4),
+            ),
+          ],
+        ),
+        child: Center(
+          child: Padding(
+            padding: const EdgeInsets.all(16.0),
+            child: Text(
+              _errorMessage!,
+              textAlign: TextAlign.center,
+              style: const TextStyle(
+                color: Colors.red,
+              ),
             ),
           ),
-          Text(
-            'Tümünü Gör',
+        ),
+      );
+    }
+    
+    if (_lastCapturedCampaign == null) {
+      return Container(
+        height: 150,
+        decoration: BoxDecoration(
+          color: Colors.white,
+          borderRadius: BorderRadius.circular(16),
+          boxShadow: [
+            BoxShadow(
+              color: Colors.black.withOpacity(0.04),
+              blurRadius: 10,
+              offset: const Offset(0, 4),
+            ),
+          ],
+        ),
+        child: const Center(
+          child: Text(
+            'Henüz yakalanmış kampanya bulunmamaktadır.',
             style: TextStyle(
-              fontSize: 14,
-              fontWeight: FontWeight.w500,
-              color: AppTheme.primaryColor,
+              color: AppTheme.textSecondaryColor,
             ),
           ),
-        ],
-      ),
-    );
-  }
-  
-  Widget _buildLastCaughtCampaign() {
+        ),
+      );
+    }
+    
+    // Get bank and card info from the campaign
+    final bankName = _lastCapturedCampaign!.bank?.name ?? 'Banka';
+    final cardName = _lastCapturedCampaign!.creditCard?.name ?? 'Kart';
+    final category = _lastCapturedCampaign!.category;
+    final discount = _lastCapturedCampaign!.formattedDiscount;
+    final expiry = 'Son: ${_lastCapturedCampaign!.endDate.day}/${_lastCapturedCampaign!.endDate.month}/${_lastCapturedCampaign!.endDate.year}';
+    
+    // Generate a color based on the bank name or use a default
+    Color cardColor;
+    if (_lastCapturedCampaign!.bank != null) {
+      // Use a consistent color based on bank name hash
+      final nameHash = bankName.hashCode.abs() % 10;
+      const colors = [
+        Color(0xFF3A86FF), // Blue
+        Color(0xFFFF006E), // Pink
+        Color(0xFF8338EC), // Purple
+        Color(0xFFFB5607), // Orange
+        Color(0xFFFFBE0B), // Yellow
+        Color(0xFF3A5A40), // Green
+        Color(0xFFE63946), // Red
+        Color(0xFF457B9D), // Teal
+        Color(0xFF9D4EDD), // Lavender
+        Color(0xFF2A9D8F), // Seafoam
+      ];
+      cardColor = colors[nameHash];
+    } else {
+      cardColor = const Color(0xFF3A86FF); // Default blue
+    }
+    
     return Container(
       decoration: BoxDecoration(
         color: Colors.white,
@@ -213,12 +407,12 @@ class _HomeTabState extends State<HomeTab> {
             children: [
               Expanded(
                 child: CampaignCard(
-                  bankName: _lastCaughtCampaign['bankName'],
-                  cardName: _lastCaughtCampaign['cardName'],
-                  discount: _lastCaughtCampaign['discount'],
-                  category: _lastCaughtCampaign['category'],
-                  expiry: _lastCaughtCampaign['expiry'],
-                  color: _lastCaughtCampaign['color'],
+                  bankName: bankName,
+                  cardName: cardName,
+                  discount: discount,
+                  category: category,
+                  expiry: expiry,
+                  color: cardColor,
                   width: double.infinity,
                   onTap: () {
                     // Navigate to campaign detail
@@ -238,12 +432,17 @@ class _HomeTabState extends State<HomeTab> {
                 ),
                 const SizedBox(width: 8),
                 Text(
-                  'Yakalandı: ${_lastCaughtCampaign['timestamp']}',
+                  'Kaynak: ${_lastCapturedCampaign!.source}',
                   style: const TextStyle(
                     fontSize: 14,
                     color: AppTheme.textSecondaryColor,
                   ),
                 ),
+                const Spacer(),
+                TextButton(
+                  onPressed: _fetchLastCapturedCampaign,
+                  child: const Text('Yenile'),
+                ),
               ],
             ),
           ),
@@ -252,156 +451,181 @@ class _HomeTabState extends State<HomeTab> {
     );
   }
   
-  Widget _buildTotalCampaignInfo() {
-    return Container(
-      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 24),
-      decoration: BoxDecoration(
-        color: Colors.white,
-        borderRadius: BorderRadius.circular(16),
-        boxShadow: [
-          BoxShadow(
-            color: Colors.black.withOpacity(0.04),
-            blurRadius: 10,
-            offset: const Offset(0, 4),
-          ),
-        ],
+  Future<void> _fetchLastCapturedCampaign() async {
+    setState(() {
+      _isLoading = true;
+      _errorMessage = null;
+    });
+    
+    try {
+      final campaign = await ApiService.getLastCapturedCampaign();
+      setState(() {
+        _lastCapturedCampaign = campaign;
+        _isLoading = false;
+      });
+    } catch (e) {
+      setState(() {
+        _errorMessage = 'Kampanya yüklenirken bir hata oluştu: $e';
+        _isLoading = false;
+      });
+      print('Error fetching last captured campaign: $e');
+    }
+  }
+  
+  Widget _buildCampaignStats() {
+    return DashboardCard(
+      title: 'Kampanya İstatistikleri',
+      trailing: Icon(
+        Icons.bar_chart,
+        color: AppTheme.primaryColor,
       ),
+      padding: const EdgeInsets.all(16),
       child: Row(
+        mainAxisAlignment: MainAxisAlignment.spaceAround,
         children: [
-          Container(
-            padding: const EdgeInsets.all(16),
-            decoration: BoxDecoration(
-              color: AppTheme.lightBlue,
-              borderRadius: BorderRadius.circular(16),
-            ),
-            child: const Icon(
-              Icons.local_offer_rounded,
-              color: AppTheme.primaryColor,
-              size: 32,
-            ),
-          ),
-          const SizedBox(width: 20),
-          Column(
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: [
-              Text(
-                '$_totalCampaignCount kampanya',
-                style: const TextStyle(
-                  fontSize: 24,
-                  fontWeight: FontWeight.bold,
-                  color: AppTheme.textPrimaryColor,
-                ),
-              ),
-              const SizedBox(height: 4),
-              const Text(
-                'senin için burada!',
-                style: TextStyle(
-                  fontSize: 16,
-                  color: AppTheme.textSecondaryColor,
-                ),
-              ),
-            ],
-          )
+          _buildStatItem('Toplam', _campaignStats['total']?.toString() ?? '0', Icons.all_inclusive),
+          _buildStatItem('Aktif', _campaignStats['active']?.toString() ?? '0', Icons.check_circle_outline),
+          _buildStatItem('Yakında Bitiyor', _campaignStats['expiring_soon']?.toString() ?? '0', Icons.timer),
         ],
       ),
     );
   }
   
-  Widget _buildBestOffer() {
-    // Show best recommendation if user has saved cards, otherwise show best campaign
-    final offerData = _hasCards ? _bestRecommendation : _bestCampaign;
-    
-    return Container(
-      decoration: BoxDecoration(
-        color: Colors.white,
-        borderRadius: BorderRadius.circular(16),
-        boxShadow: [
-          BoxShadow(
-            color: Colors.black.withOpacity(0.04),
-            blurRadius: 10,
-            offset: const Offset(0, 4),
-          ),
-        ],
-      ),
-      child: Column(
-        children: [
-          Row(
-            children: [
-              Expanded(
-                child: CampaignCard(
-                  bankName: offerData['bankName'],
-                  cardName: offerData['cardName'],
-                  discount: offerData['discount'],
-                  category: offerData['category'],
-                  expiry: offerData['expiry'],
-                  color: offerData['color'],
-                  width: double.infinity,
-                  onTap: () {
-                    // Navigate to campaign detail
-                  },
-                ),
-              ),
-            ],
+  Widget _buildStatItem(String label, String value, IconData icon) {
+    return Column(
+      children: [
+        Icon(
+          icon,
+          color: AppTheme.primaryColor,
+          size: 28,
+        ),
+        const SizedBox(height: 8),
+        Text(
+          value,
+          style: const TextStyle(
+            fontSize: 20,
+            fontWeight: FontWeight.bold,
+            color: AppTheme.textPrimaryColor,
           ),
-          Padding(
-            padding: const EdgeInsets.all(12),
-            child: Row(
-              children: [
-                Icon(
-                  _hasCards ? Icons.recommend_rounded : Icons.star_rate_rounded,
-                  size: 16,
-                  color: AppTheme.textSecondaryColor,
-                ),
-                const SizedBox(width: 8),
-                Text(
-                  _hasCards 
-                    ? 'Kartlarınıza göre özelleştirilmiş öneri'
-                    : 'En yüksek indirim oranına sahip kampanya',
-                  style: const TextStyle(
-                    fontSize: 14,
-                    color: AppTheme.textSecondaryColor,
-                  ),
-                ),
-              ],
-            ),
+        ),
+        const SizedBox(height: 4),
+        Text(
+          label,
+          style: const TextStyle(
+            fontSize: 12,
+            color: AppTheme.textSecondaryColor,
           ),
-        ],
-      ),
+        ),
+      ],
     );
   }
   
-  Widget _buildTodaysCampaigns() {
+  Widget _buildCategoryCampaigns() {
+    // Only show categories with campaigns
+    final categoriesToShow = _campaignsByCategory.keys.where(
+      (category) => _campaignsByCategory[category]!.isNotEmpty
+    ).toList();
+    
+    if (categoriesToShow.isEmpty) return const SizedBox.shrink();
+    
     return Column(
-      children: _todaysCampaigns.map((campaign) => 
-        Padding(
-          padding: const EdgeInsets.only(bottom: 16),
-          child: Container(
-            decoration: BoxDecoration(
-              color: Colors.white,
-              borderRadius: BorderRadius.circular(16),
-              boxShadow: [
-                BoxShadow(
-                  color: Colors.black.withOpacity(0.04),
-                  blurRadius: 10,
-                  offset: const Offset(0, 4),
-                ),
-              ],
+      children: categoriesToShow.map((category) {
+        return DashboardCard(
+          title: '$category Kampanyaları',
+          trailing: Text(
+            'Tümünü Gör',
+            style: TextStyle(
+              fontSize: 14,
+              fontWeight: FontWeight.w500,
+              color: AppTheme.primaryColor,
             ),
-            child: CampaignCard(
-              bankName: campaign['bankName'],
-              cardName: campaign['cardName'],
-              discount: campaign['discount'],
-              category: campaign['category'],
-              expiry: campaign['expiry'],
-              color: campaign['color'],
-              width: double.infinity,
-              onTap: () {
-                // Navigate to campaign detail
+          ),
+          onTap: () {
+            // Navigate to category campaigns page
+          },
+          child: SizedBox(
+            height: 180,
+            child: ListView.builder(
+              scrollDirection: Axis.horizontal,
+              itemCount: _campaignsByCategory[category]!.length,
+              itemBuilder: (context, index) {
+                final campaign = _campaignsByCategory[category]![index];
+                return Padding(
+                  padding: EdgeInsets.only(
+                    right: index < _campaignsByCategory[category]!.length - 1 ? 12 : 0,
+                  ),
+                  child: CampaignCard(
+                    bankName: campaign.bank?.name ?? 'Bank',
+                    cardName: campaign.creditCard?.name ?? 'Card',
+                    discount: campaign.formattedDiscount,
+                    category: campaign.category,
+                    expiry: campaign.timeRemaining,
+                    color: _getColorForIndex(index),
+                    width: 280,
+                    onTap: () {
+                      // Navigate to campaign detail
+                    },
+                  ),
+                );
               },
             ),
           ),
-        )
-      ).toList(),
+        );
+      }).toList(),
+    );
+  }
+
+  Color _getColorForIndex(int index) {
+    final colors = [
+      const Color(0xFF3A86FF),  // Blue
+      const Color(0xFF8338EC),  // Purple
+      const Color(0xFFFF006E),  // Pink
+      const Color(0xFFFB5607),  // Orange
+      const Color(0xFFFFBE0B),  // Yellow
+      const Color(0xFF06D6A0),  // Teal
+    ];
+    
+    return colors[index % colors.length];
+  }
+
+  Widget _buildErrorIndicator() {
+    return Center(
+      child: Padding(
+        padding: const EdgeInsets.all(24.0),
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            const Icon(
+              Icons.error_outline,
+              color: Colors.red,
+              size: 48,
+            ),
+            const SizedBox(height: 16),
+            const Text(
+              'Failed to load campaign data',
+              style: TextStyle(
+                fontSize: 18,
+                fontWeight: FontWeight.bold,
+              ),
+            ),
+            const SizedBox(height: 8),
+            Text(
+              _errorMessage ?? 'Unknown error',
+              textAlign: TextAlign.center,
+              style: const TextStyle(
+                fontSize: 14,
+                color: Colors.grey,
+              ),
+            ),
+            const SizedBox(height: 24),
+            ElevatedButton.icon(
+              onPressed: _loadDashboardData,
+              icon: const Icon(Icons.refresh),
+              label: const Text('Retry'),
+            ),
+          ],
+        ),
+      ),
     );
   }
 } 
\ No newline at end of file
diff --git a/flutter_app/lib/screens/dashboard/tabs/profile_tab.dart b/flutter_app/lib/screens/dashboard/tabs/profile_tab.dart
index 752ee88..30200d3 100644
--- a/flutter_app/lib/screens/dashboard/tabs/profile_tab.dart
+++ b/flutter_app/lib/screens/dashboard/tabs/profile_tab.dart
@@ -72,9 +72,16 @@ class _ProfileTabState extends State<ProfileTab> {
                     color: AppTheme.primaryColor.withOpacity(0.3),
                     width: 4,
                   ),
-                  image: const DecorationImage(
-                    image: AssetImage('assets/images/avatar.png'),
-                    fit: BoxFit.cover,
+                  color: AppTheme.primaryColor.withOpacity(0.2),
+                ),
+                child: Center(
+                  child: Text(
+                    _userData['name'].toString().split(' ').map((name) => name[0]).join(''),
+                    style: TextStyle(
+                      fontSize: 40,
+                      fontWeight: FontWeight.bold,
+                      color: AppTheme.primaryColor,
+                    ),
                   ),
                 ),
               ),
diff --git a/flutter_app/lib/screens/login_test.dart b/flutter_app/lib/screens/login_test.dart
new file mode 100644
index 0000000..a92c664
--- /dev/null
+++ b/flutter_app/lib/screens/login_test.dart
@@ -0,0 +1,81 @@
+import 'package:flutter/material.dart';
+import 'package:payviya_app/services/auth_service.dart';
+
+class LoginTestScreen extends StatefulWidget {
+  const LoginTestScreen({Key? key}) : super(key: key);
+
+  @override
+  State<LoginTestScreen> createState() => _LoginTestScreenState();
+}
+
+class _LoginTestScreenState extends State<LoginTestScreen> {
+  String _status = "Ready to test";
+  final _emailController = TextEditingController(text: "user@example.com");
+  final _passwordController = TextEditingController(text: "password");
+
+  @override
+  void dispose() {
+    _emailController.dispose();
+    _passwordController.dispose();
+    super.dispose();
+  }
+
+  Future<void> _testLogin() async {
+    setState(() {
+      _status = "Testing login with: ${_emailController.text} / ${_passwordController.text}";
+    });
+
+    try {
+      final user = await AuthService.login(
+        email: _emailController.text,
+        password: _passwordController.text,
+      );
+
+      setState(() {
+        _status = "Login successful! User: ${user.name} (${user.email})";
+      });
+    } catch (e) {
+      setState(() {
+        _status = "Login failed: $e";
+      });
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Scaffold(
+      appBar: AppBar(
+        title: const Text("Login Test"),
+      ),
+      body: Padding(
+        padding: const EdgeInsets.all(20.0),
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            TextField(
+              controller: _emailController,
+              decoration: const InputDecoration(labelText: "Email"),
+            ),
+            const SizedBox(height: 10),
+            TextField(
+              controller: _passwordController,
+              decoration: const InputDecoration(labelText: "Password"),
+              obscureText: true,
+            ),
+            const SizedBox(height: 20),
+            Text(
+              _status,
+              style: const TextStyle(fontSize: 16),
+              textAlign: TextAlign.center,
+            ),
+            const SizedBox(height: 20),
+            ElevatedButton(
+              onPressed: _testLogin,
+              child: const Text("Test Login"),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+} 
\ No newline at end of file
diff --git a/flutter_app/lib/services/api_service.dart b/flutter_app/lib/services/api_service.dart
index 3342d8a..877729d 100644
--- a/flutter_app/lib/services/api_service.dart
+++ b/flutter_app/lib/services/api_service.dart
@@ -9,10 +9,10 @@ class ApiService {
   static String get baseUrl {
     if (kIsWeb) {
       // For web deployment, use the localhost with the correct port
-      return 'http://localhost:8001/api/v1';
+      return 'http://localhost:8001';
     } else {
       // For mobile devices, use your server IP (use the actual IP address when testing on physical devices)
-      return 'http://10.0.2.2:8001/api/v1'; // Use 10.0.2.2 for Android emulator
+      return 'http://10.0.2.2:8001'; // Use 10.0.2.2 for Android emulator
     }
   }
   
@@ -26,76 +26,183 @@ class ApiService {
   static void setToken(String token) {
     headers['Authorization'] = 'Bearer $token';
     print('Token set in headers: Bearer $token');
+    
+    // Decode JWT to show user info
+    try {
+      final parts = token.split('.');
+      if (parts.length == 3) {
+        final payload = parts[1];
+        final normalized = base64Url.normalize(payload);
+        final decoded = utf8.decode(base64Url.decode(normalized));
+        print('Decoded token: $decoded');
+      }
+    } catch (e) {
+      print('Error decoding token: $e');
+    }
   }
 
   // GET request helper
   static Future<dynamic> get(String endpoint) async {
+    final url = '$baseUrl$endpoint';
+    print('GET request to: $url');
     try {
       final response = await http.get(
-        Uri.parse('$baseUrl$endpoint'),
+        Uri.parse(url),
         headers: headers,
       );
       
+      print('Response status code: ${response.statusCode}');
+      if (response.statusCode >= 200 && response.statusCode < 300) {
+        print('Response body length: ${response.body.length} bytes');
+      } else {
+        print('Error response: ${response.body}');
+      }
+      
       return _processResponse(response);
     } catch (e) {
+      print('Network error during GET request to $url: $e');
       throw Exception('Failed to connect to server: $e');
     }
   }
   
   // POST request helper
   static Future<dynamic> post(String endpoint, dynamic data) async {
+    final url = '$baseUrl$endpoint';
+    print('POST request to: $url');
+    print('Request body: ${jsonEncode(data)}');
+    
     try {
       final response = await http.post(
-        Uri.parse('$baseUrl$endpoint'),
+        Uri.parse(url),
         headers: headers,
         body: jsonEncode(data),
       );
       
+      print('Response status code: ${response.statusCode}');
+      if (response.statusCode >= 200 && response.statusCode < 300) {
+        print('Response body length: ${response.body.length} bytes');
+      } else {
+        print('Error response: ${response.body}');
+      }
+      
       return _processResponse(response);
     } catch (e) {
+      print('Network error during POST request to $url: $e');
       throw Exception('Failed to connect to server: $e');
     }
   }
   
   // Process the HTTP response
   static dynamic _processResponse(http.Response response) {
-    switch (response.statusCode) {
-      case 200:
-      case 201:
-        return jsonDecode(response.body);
-      case 400:
-        throw Exception('Bad request: ${response.body}');
-      case 401:
-        throw Exception('Unauthorized');
-      case 403:
-        throw Exception('Forbidden');
-      case 404:
-        throw Exception('Resource not found');
-      case 500:
-        throw Exception('Server error');
-      default:
-        throw Exception('Error occurred: ${response.statusCode}');
+    try {
+      switch (response.statusCode) {
+        case 200:
+        case 201:
+          if (response.body.isEmpty) {
+            return {};
+          }
+          return jsonDecode(response.body);
+        case 400:
+          print('Bad request: ${response.body}');
+          throw Exception('Bad request: ${response.body}');
+        case 401:
+          print('Unauthorized: ${response.body}');
+          throw Exception('Unauthorized');
+        case 403:
+          print('Forbidden: ${response.body}');
+          throw Exception('Forbidden');
+        case 404:
+          print('Resource not found: ${response.body}');
+          throw Exception('Resource not found');
+        case 422:
+          print('Validation error: ${response.body}');
+          throw Exception('Validation error: ${response.body}');
+        case 500:
+          print('Server error: ${response.body}');
+          throw Exception('Server error');
+        default:
+          print('Error occurred (${response.statusCode}): ${response.body}');
+          throw Exception('Error occurred: ${response.statusCode}');
+      }
+    } catch (e) {
+      print('Exception during response processing: $e');
+      throw e;
     }
   }
   
   // Campaign-specific API calls
   static Future<List<Campaign>> getCampaigns({int skip = 0, int limit = 20}) async {
-    final data = await get('/campaigns?skip=$skip&limit=$limit');
-    
-    // Convert JSON data to Campaign objects
-    List<Campaign> campaigns = [];
-    for (var item in data) {
-      campaigns.add(Campaign.fromJson(item));
+    try {
+      final data = await get('/api/v1/campaigns?skip=$skip&limit=$limit');
+      
+      // Convert JSON data to Campaign objects
+      List<Campaign> campaigns = [];
+      if (data is List) {
+        for (var item in data) {
+          campaigns.add(Campaign.fromJson(item));
+        }
+      } else if (data is Map && data.containsKey('items')) {
+        for (var item in data['items']) {
+          campaigns.add(Campaign.fromJson(item));
+        }
+      } else {
+        print('Unexpected response format: $data');
+      }
+      
+      return campaigns;
+    } catch (e) {
+      print('Error fetching campaigns: $e');
+      rethrow; // Rethrow the exception to be handled by the UI
     }
-    
-    return campaigns;
   }
   
   static Future<Campaign> getCampaignById(int id) async {
-    final data = await get('/campaigns/$id');
+    final data = await get('/api/v1/campaigns/$id');
     return Campaign.fromJson(data);
   }
   
+  static Future<Map<String, dynamic>> getCampaignStats() async {
+    try {
+      return await get('/api/v1/campaigns/stats');
+    } catch (e) {
+      print('Error fetching campaign stats: $e');
+      rethrow; // Rethrow the exception to be handled by the UI
+    }
+  }
+  
+  static Future<List<String>> getCampaignCategories() async {
+    try {
+      final data = await get('/api/v1/campaigns/categories');
+      
+      List<String> categories = [];
+      if (data is List) {
+        for (var item in data) {
+          if (item is String) {
+            categories.add(item);
+          }
+        }
+      }
+      
+      return categories;
+    } catch (e) {
+      print('Error fetching campaign categories: $e');
+      rethrow; // Rethrow the exception to be handled by the UI
+    }
+  }
+  
+  static Future<Campaign> getLastCapturedCampaign() async {
+    try {
+      final data = await get('/api/v1/campaigns/last-captured');
+      if (data == null) {
+        throw Exception('Empty response from server');
+      }
+      return Campaign.fromJson(data);
+    } catch (e) {
+      print('Error fetching last captured campaign: $e');
+      rethrow; // Rethrow the exception to be handled by the UI
+    }
+  }
+  
   static Future<List<Campaign>> searchCampaigns(String query) async {
     final data = await get('/campaigns/search?q=$query');
     
@@ -111,8 +218,14 @@ class ApiService {
     final data = await get('/campaigns/category/$category');
     
     List<Campaign> campaigns = [];
-    for (var item in data) {
-      campaigns.add(Campaign.fromJson(item));
+    if (data is List) {
+      for (var item in data) {
+        campaigns.add(Campaign.fromJson(item));
+      }
+    } else if (data is Map && data.containsKey('items')) {
+      for (var item in data['items']) {
+        campaigns.add(Campaign.fromJson(item));
+      }
     }
     
     return campaigns;
@@ -122,8 +235,14 @@ class ApiService {
     final data = await get('/recommendations/campaigns');
     
     List<Campaign> campaigns = [];
-    for (var item in data) {
-      campaigns.add(Campaign.fromJson(item));
+    if (data is List) {
+      for (var item in data) {
+        campaigns.add(Campaign.fromJson(item));
+      }
+    } else if (data is Map && data.containsKey('items')) {
+      for (var item in data['items']) {
+        campaigns.add(Campaign.fromJson(item));
+      }
     }
     
     return campaigns;
@@ -134,8 +253,14 @@ class ApiService {
     final data = await get('/banks');
     
     List<Bank> banks = [];
-    for (var item in data) {
-      banks.add(Bank.fromJson(item));
+    if (data is List) {
+      for (var item in data) {
+        banks.add(Bank.fromJson(item));
+      }
+    } else if (data is Map && data.containsKey('items')) {
+      for (var item in data['items']) {
+        banks.add(Bank.fromJson(item));
+      }
     }
     
     return banks;
@@ -146,8 +271,14 @@ class ApiService {
     final data = await get('/credit-cards');
     
     List<CreditCard> cards = [];
-    for (var item in data) {
-      cards.add(CreditCard.fromJson(item));
+    if (data is List) {
+      for (var item in data) {
+        cards.add(CreditCard.fromJson(item));
+      }
+    } else if (data is Map && data.containsKey('items')) {
+      for (var item in data['items']) {
+        cards.add(CreditCard.fromJson(item));
+      }
     }
     
     return cards;
diff --git a/flutter_app/lib/services/auth_service.dart b/flutter_app/lib/services/auth_service.dart
index 66b4e10..7f1d287 100644
--- a/flutter_app/lib/services/auth_service.dart
+++ b/flutter_app/lib/services/auth_service.dart
@@ -1,11 +1,15 @@
 import 'dart:convert';
-import 'package:http/http.dart' as http;
-import 'package:shared_preferences/shared_preferences.dart';
+import 'package:flutter/foundation.dart' show kIsWeb;
+import 'package:flutter_secure_storage/flutter_secure_storage.dart';
 import 'package:payviya_app/services/api_service.dart';
 import 'package:payviya_app/services/user_service.dart';
+import 'package:http/http.dart' as http;
 import 'package:payviya_app/models/user.dart';
 
 class AuthService {
+  static const storage = FlutterSecureStorage();
+  static const _tokenKey = 'auth_token';
+  
   // Auth-specific API endpoints
   static Future<Map<String, dynamic>> register({
     required String email,
@@ -33,65 +37,89 @@ class AuthService {
     }
   }
 
-  static Future<User> login({
-    required String email,
-    required String password,
-  }) async {
+  // Login with email and password
+  static Future<User> login({required String email, required String password}) async {
     try {
-      print('Sending login request to: ${ApiService.baseUrl}/auth/login/access-token');
+      print('Sending login request to: ${ApiService.baseUrl}/api/v1/auth/login/access-token');
+      
+      // Use the appropriate content type for form data
+      ApiService.headers['Content-Type'] = 'application/x-www-form-urlencoded';
+      
+      // Prepare the request body
+      final body = {
+        'username': email,
+        'password': password,
+      };
       
-      // For OAuth2 form data format, we need a direct HTTP call
+      // Convert the body to URL encoded format
+      final encodedBody = body.entries
+          .map((e) => '${Uri.encodeComponent(e.key)}=${Uri.encodeComponent(e.value)}')
+          .join('&');
+          
+      // Send the POST request directly without using ApiService.post
+      final uri = Uri.parse('${ApiService.baseUrl}/api/v1/auth/login/access-token');
       final response = await http.post(
-        Uri.parse('${ApiService.baseUrl}/auth/login/access-token'),
-        headers: {
-          'Content-Type': 'application/x-www-form-urlencoded',
-          'Accept': 'application/json',
-        },
-        body: 'username=${Uri.encodeComponent(email)}&password=${Uri.encodeComponent(password)}',
+        uri, 
+        headers: ApiService.headers, 
+        body: encodedBody
       );
       
+      // Reset content type for future requests
+      ApiService.headers['Content-Type'] = 'application/json';
+      
       print('Login response status: ${response.statusCode}');
-      print('Login response body: ${response.body}');
       
-      if (response.statusCode == 200 || response.statusCode == 201) {
-        final tokenData = jsonDecode(response.body);
+      if (response.statusCode == 200) {
+        final responseData = jsonDecode(response.body);
+        print('Login response body:\n${response.body}');
         
-        // Save token to local storage
-        await _saveToken(tokenData['access_token']);
+        // Save the token
+        final token = responseData['access_token'];
+        await storage.write(key: _tokenKey, value: token);
         
-        // Set token in API service for subsequent requests
-        ApiService.setToken(tokenData['access_token']);
+        // Set the token in the API service
+        ApiService.setToken(token);
         
-        // Fetch user profile
-        final user = await UserService.fetchUserProfile();
-        if (user == null) {
-          throw Exception('Failed to fetch user profile after login');
+        // Fetch the user profile after login and return it
+        try {
+          User? user = await UserService.fetchUserProfile();
+          if (user == null) {
+            throw Exception('Kullanıcı profili alınamadı');
+          }
+          return user;
+        } catch (profileError) {
+          print('Error fetching user profile after login: $profileError');
+          throw Exception('Giriş başarılı, ancak kullanıcı bilgileri alınamadı');
         }
-        
-        return user;
       } else {
-        // Handle specific error cases
-        final errorBody = response.body;
+        print('Login error: ${response.body}');
         try {
-          final errorData = jsonDecode(errorBody);
-          final errorDetail = errorData['detail'] ?? 'Login failed';
-          
-          // Handle specific error messages for better user feedback
-          if (errorDetail.toString().contains('Incorrect email or password')) {
-            throw Exception('E-posta veya şifre hatalı');
-          } else if (errorDetail.toString().contains('Inactive user')) {
-            throw Exception('Hesabınız aktif değil. Lütfen yönetici ile iletişime geçin.');
-          } else {
-            throw Exception(errorDetail);
+          final errorData = jsonDecode(response.body);
+          if (errorData['detail'] != null) {
+            if (errorData['detail'].toString().contains('Incorrect')) {
+              throw Exception('E-posta veya şifre hatalı');
+            } else if (errorData['detail'].toString().contains('not active')) {
+              throw Exception('Hesabınız aktif değil');
+            }
+            throw Exception(errorData['detail']);
           }
         } catch (e) {
-          // If we can't parse the error JSON, fall back to a generic message
-          throw Exception('Giriş başarısız: ${response.statusCode}');
+          // If we can't parse the error JSON
+          if (response.statusCode == 401) {
+            throw Exception('E-posta veya şifre hatalı');
+          } else if (response.statusCode == 403) {
+            throw Exception('Erişim reddedildi');
+          } else if (response.statusCode == 404) {
+            throw Exception('Sunucu bağlantısı kurulamadı');
+          } else if (response.statusCode >= 500) {
+            throw Exception('Sunucu hatası. Lütfen daha sonra tekrar deneyin');
+          }
         }
+        throw Exception('Giriş başarısız: ${response.statusCode}');
       }
     } catch (e) {
       print('Login error: $e');
-      // Re-throw with a cleaner error message if it's not already an Exception
+      // If it's already an Exception, just rethrow it
       if (e is Exception) {
         throw e;
       }
@@ -99,32 +127,24 @@ class AuthService {
     }
   }
 
-  static Future<void> logout() async {
-    // Clear token from shared preferences
-    final prefs = await SharedPreferences.getInstance();
-    await prefs.remove('auth_token');
-    
-    // Clear token from API service
-    ApiService.headers.remove('Authorization');
-    
-    // Clear user data
-    await UserService.clearUserData();
-  }
-
+  // Check if user is logged in
   static Future<bool> isLoggedIn() async {
-    final prefs = await SharedPreferences.getInstance();
-    final token = prefs.getString('auth_token');
-    return token != null && token.isNotEmpty;
+    final token = await getToken();
+    return token != null;
   }
 
-  static Future<void> _saveToken(String token) async {
-    final prefs = await SharedPreferences.getInstance();
-    await prefs.setString('auth_token', token);
+  // Get stored token
+  static Future<String?> getToken() async {
+    return await storage.read(key: _tokenKey);
   }
 
-  static Future<String?> getToken() async {
-    final prefs = await SharedPreferences.getInstance();
-    return prefs.getString('auth_token');
+  // Logout user
+  static Future<void> logout() async {
+    // Clear the token
+    await storage.delete(key: _tokenKey);
+    
+    // Clear user data
+    await UserService.clearUserData();
   }
 
   static Future<void> initializeAuth() async {
diff --git a/flutter_app/lib/services/campaign_service.dart b/flutter_app/lib/services/campaign_service.dart
new file mode 100644
index 0000000..561fffa
--- /dev/null
+++ b/flutter_app/lib/services/campaign_service.dart
@@ -0,0 +1,84 @@
+import 'dart:convert';
+import 'package:payviya_app/models/campaign.dart';
+import 'package:payviya_app/services/api_service.dart';
+
+class CampaignService {
+  // Get featured campaigns for the dashboard
+  static Future<Map<String, dynamic>> getDashboardCampaigns() async {
+    // Get recent campaigns
+    final recentCampaigns = await ApiService.getCampaigns(limit: 5);
+    
+    // Get recommended campaigns
+    final recommendedCampaigns = await ApiService.getRecommendedCampaigns();
+    
+    // Get campaigns by category
+    final List<String> popularCategories = ['Supermarket', 'Restaurant', 'Electronics'];
+    final Map<String, List<Campaign>> campaignsByCategory = {};
+    
+    for (String category in popularCategories) {
+      try {
+        final campaigns = await ApiService.getCampaignsByCategory(category);
+        campaignsByCategory[category] = campaigns;
+      } catch (e) {
+        print('Error fetching campaigns for category $category: $e');
+        campaignsByCategory[category] = [];
+      }
+    }
+    
+    return {
+      'recent': recentCampaigns,
+      'recommended': recommendedCampaigns,
+      'by_category': campaignsByCategory,
+    };
+  }
+  
+  // Get campaign statistics
+  static Future<Map<String, dynamic>> getCampaignStats() async {
+    final response = await ApiService.get('/api/v1/campaigns/stats');
+    return response;
+  }
+  
+  // Get the last captured/used campaign
+  static Future<Campaign?> getLastCapturedCampaign() async {
+    try {
+      final response = await ApiService.get('/api/v1/campaigns/last-captured');
+      // If we got here, we have a 200 OK response as ApiService.get() throws exceptions for non-200 responses
+      if (response != null) {
+        return Campaign.fromJson(response);
+      }
+      return null;
+    } catch (e) {
+      print('Error fetching last captured campaign: $e');
+      return null;
+    }
+  }
+  
+  // Get campaigns expiring soon
+  static Future<List<Campaign>> getExpiringSoonCampaigns() async {
+    final response = await ApiService.get('/api/v1/campaigns/expiring-soon');
+    
+    List<Campaign> campaigns = [];
+    if (response is List) {
+      for (var item in response) {
+        campaigns.add(Campaign.fromJson(item));
+      }
+    } else if (response is Map && response.containsKey('items')) {
+      for (var item in response['items']) {
+        campaigns.add(Campaign.fromJson(item));
+      }
+    }
+    
+    return campaigns;
+  }
+  
+  // Get campaign categories
+  static Future<List<String>> getCampaignCategories() async {
+    final response = await ApiService.get('/api/v1/campaigns/categories');
+    if (response is List) {
+      return List<String>.from(response);
+    } else if (response is Map && response.containsKey('categories')) {
+      return List<String>.from(response['categories']);
+    }
+    return [];
+  }
+} 
\ No newline at end of file
diff --git a/flutter_app/lib/services/user_service.dart b/flutter_app/lib/services/user_service.dart
index 17b08c6..0b12fa6 100644
--- a/flutter_app/lib/services/user_service.dart
+++ b/flutter_app/lib/services/user_service.dart
@@ -39,7 +39,7 @@ class UserService {
       // Try to fetch from API first
       try {
         print('Attempting to fetch user profile from API');
-        final userData = await ApiService.get('/users/me');
+        final userData = await ApiService.get('/api/v1/users/me');
         print('User data fetched successfully: $userData');
         
         final user = User.fromJson(userData);
@@ -60,13 +60,15 @@ class UserService {
           print('Decoded token: $decodedToken');
           
           final userId = decodedToken['sub'];
+          final userName = decodedToken['name'] ?? 'User';
+          final userEmail = decodedToken['email'] ?? userId.toString();
           
           // Create a placeholder user with minimal information
           final user = User(
-            id: 1, // Use a default ID
-            email: userId,
-            name: 'Test',
-            surname: 'User',
+            id: int.tryParse(userId) ?? 1,
+            email: userEmail,
+            name: userName,
+            surname: '',
             isActive: true,
             isAdmin: false,
           );
@@ -93,7 +95,7 @@ class UserService {
     String? phone,
   }) async {
     try {
-      final userData = await ApiService.post('/users/update', {
+      final userData = await ApiService.post('/api/v1/users/update', {
         if (name != null) 'name': name,
         if (surname != null) 'surname': surname,
         if (email != null) 'email': email,
diff --git a/flutter_app/lib/widgets/dashboard_card.dart b/flutter_app/lib/widgets/dashboard_card.dart
new file mode 100644
index 0000000..73dbca6
--- /dev/null
+++ b/flutter_app/lib/widgets/dashboard_card.dart
@@ -0,0 +1,82 @@
+import 'package:flutter/material.dart';
+import 'package:payviya_app/core/theme/app_theme.dart';
+
+class DashboardCard extends StatelessWidget {
+  final Widget child;
+  final String? title;
+  final VoidCallback? onTap;
+  final EdgeInsetsGeometry padding;
+  final EdgeInsetsGeometry margin;
+  final double borderRadius;
+  final Color backgroundColor;
+  final double elevation;
+  final Widget? trailing;
+  
+  const DashboardCard({
+    Key? key,
+    required this.child,
+    this.title,
+    this.onTap,
+    this.padding = const EdgeInsets.all(16),
+    this.margin = const EdgeInsets.only(bottom: 16),
+    this.borderRadius = 16,
+    this.backgroundColor = Colors.white,
+    this.elevation = 1,
+    this.trailing,
+  }) : super(key: key);
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      margin: margin,
+      decoration: BoxDecoration(
+        color: backgroundColor,
+        borderRadius: BorderRadius.circular(borderRadius),
+        boxShadow: [
+          BoxShadow(
+            color: Colors.black.withOpacity(0.04),
+            blurRadius: 10,
+            offset: const Offset(0, 4),
+            spreadRadius: elevation,
+          ),
+        ],
+      ),
+      child: Material(
+        color: Colors.transparent,
+        child: InkWell(
+          onTap: onTap,
+          borderRadius: BorderRadius.circular(borderRadius),
+          child: Column(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              if (title != null) ...[
+                Padding(
+                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
+                  child: Row(
+                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
+                    children: [
+                      Text(
+                        title!,
+                        style: const TextStyle(
+                          fontSize: 18,
+                          fontWeight: FontWeight.bold,
+                          color: AppTheme.textPrimaryColor,
+                        ),
+                      ),
+                      if (trailing != null) trailing!,
+                    ],
+                  ),
+                ),
+                const Divider(),
+              ],
+              Padding(
+                padding: padding,
+                child: child,
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+} 
\ No newline at end of file
diff --git a/flutter_app/lib/widgets/error_indicator.dart b/flutter_app/lib/widgets/error_indicator.dart
new file mode 100644
index 0000000..c9d96aa
--- /dev/null
+++ b/flutter_app/lib/widgets/error_indicator.dart
@@ -0,0 +1,70 @@
+import 'package:flutter/material.dart';
+import 'package:payviya_app/core/theme/app_theme.dart';
+
+class ErrorIndicator extends StatelessWidget {
+  final String message;
+  final VoidCallback? onRetry;
+  final IconData icon;
+  
+  const ErrorIndicator({
+    Key? key,
+    this.message = 'Bir hata oluştu. Lütfen tekrar deneyiniz.',
+    this.onRetry,
+    this.icon = Icons.error_outline_rounded,
+  }) : super(key: key);
+
+  @override
+  Widget build(BuildContext context) {
+    return Center(
+      child: Padding(
+        padding: const EdgeInsets.symmetric(horizontal: 32.0),
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          crossAxisAlignment: CrossAxisAlignment.center,
+          children: [
+            Icon(
+              icon,
+              color: AppTheme.errorColor,
+              size: 48,
+            ),
+            const SizedBox(height: 16),
+            Text(
+              message,
+              textAlign: TextAlign.center,
+              style: const TextStyle(
+                fontSize: 16,
+                color: AppTheme.textPrimaryColor,
+                fontWeight: FontWeight.w500,
+              ),
+            ),
+            if (onRetry != null) ...[
+              const SizedBox(height: 24),
+              ElevatedButton(
+                onPressed: onRetry,
+                style: ElevatedButton.styleFrom(
+                  backgroundColor: AppTheme.primaryColor,
+                  foregroundColor: Colors.white,
+                  elevation: 2,
+                  shape: RoundedRectangleBorder(
+                    borderRadius: BorderRadius.circular(8),
+                  ),
+                  padding: const EdgeInsets.symmetric(
+                    horizontal: 24,
+                    vertical: 12,
+                  ),
+                ),
+                child: const Text(
+                  'Tekrar Dene',
+                  style: TextStyle(
+                    fontSize: 16,
+                    fontWeight: FontWeight.w600,
+                  ),
+                ),
+              ),
+            ],
+          ],
+        ),
+      ),
+    );
+  }
+} 
\ No newline at end of file
diff --git a/flutter_app/lib/widgets/loading_indicator.dart b/flutter_app/lib/widgets/loading_indicator.dart
new file mode 100644
index 0000000..c986a37
--- /dev/null
+++ b/flutter_app/lib/widgets/loading_indicator.dart
@@ -0,0 +1,44 @@
+import 'package:flutter/material.dart';
+import 'package:payviya_app/core/theme/app_theme.dart';
+
+class LoadingIndicator extends StatelessWidget {
+  final String? message;
+  final double size;
+  
+  const LoadingIndicator({
+    Key? key,
+    this.message,
+    this.size = 40.0,
+  }) : super(key: key);
+
+  @override
+  Widget build(BuildContext context) {
+    return Center(
+      child: Column(
+        mainAxisAlignment: MainAxisAlignment.center,
+        crossAxisAlignment: CrossAxisAlignment.center,
+        children: [
+          SizedBox(
+            width: size,
+            height: size,
+            child: CircularProgressIndicator(
+              color: AppTheme.primaryColor,
+              strokeWidth: 3,
+            ),
+          ),
+          if (message != null) ...[
+            const SizedBox(height: 16),
+            Text(
+              message!,
+              textAlign: TextAlign.center,
+              style: const TextStyle(
+                fontSize: 16,
+                color: AppTheme.textSecondaryColor,
+              ),
+            ),
+          ],
+        ],
+      ),
+    );
+  }
+} 
\ No newline at end of file
diff --git a/flutter_app/pubspec.lock b/flutter_app/pubspec.lock
index c07227b..3b6f57a 100644
--- a/flutter_app/pubspec.lock
+++ b/flutter_app/pubspec.lock
@@ -504,6 +504,14 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "4.9.0"
+  jwt_decoder:
+    dependency: "direct main"
+    description:
+      name: jwt_decoder
+      sha256: "54774aebf83f2923b99e6416b4ea915d47af3bde56884eb622de85feabbc559f"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.0.1"
   leak_tracker:
     dependency: transitive
     description:
diff --git a/flutter_app/pubspec.yaml b/flutter_app/pubspec.yaml
index 82906e8..5e99a54 100644
--- a/flutter_app/pubspec.yaml
+++ b/flutter_app/pubspec.yaml
@@ -45,6 +45,7 @@ flutter:
     - family: Roboto
       fonts:
         - asset: assets/fonts/Roboto-Regular.ttf
+          weight: 400
         - asset: assets/fonts/Roboto-Medium.ttf
           weight: 500
         - asset: assets/fonts/Roboto-Bold.ttf
diff --git a/main.py b/main.py
new file mode 100644
index 0000000..049b119
--- /dev/null
+++ b/main.py
@@ -0,0 +1,84 @@
+import logging
+import uvicorn
+import os
+import sys
+from fastapi import FastAPI
+from fastapi.middleware.cors import CORSMiddleware
+from apscheduler.schedulers.background import BackgroundScheduler
+
+# Add the current directory to path to fix import issues
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Now use absolute imports
+from api.api.v1.router import api_router
+from api.core.config import settings
+from api.tasks.campaign_sync_task import schedule_campaign_sync
+
+# Configure logging
+logging.basicConfig(
+    level=logging.INFO,
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
+)
+logger = logging.getLogger(__name__)
+
+app = FastAPI(
+    title="PayViya API",
+    description="Payment assistant API for card recommendations and campaign participation",
+    version="0.1.0",
+    openapi_url=f"{settings.API_V1_STR}/openapi.json",
+    docs_url="/docs",
+    redoc_url="/redoc",
+)
+
+# Add CORS middleware
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],  # Allow all origins for development (restrict this in production)
+    allow_credentials=True,
+    allow_methods=["*"],  # Allow all methods
+    allow_headers=["*"],  # Allow all headers
+)
+
+# Include API routes
+app.include_router(api_router, prefix="/api/v1")
+
+# Set up APScheduler for background tasks
+scheduler = BackgroundScheduler()
+
+@app.on_event("startup")
+async def startup_event():
+    """Initialize services on startup"""
+    logger.info("Starting application...")
+    
+    # Schedule campaign sync tasks
+    schedule_campaign_sync(scheduler)
+    
+    # Start the scheduler
+    scheduler.start()
+    
+    logger.info("Application startup complete")
+
+@app.on_event("shutdown")
+async def shutdown_event():
+    """Clean up on shutdown"""
+    logger.info("Shutting down application...")
+    
+    # Shut down the scheduler
+    if scheduler.running:
+        scheduler.shutdown()
+    
+    logger.info("Application shutdown complete")
+
+# Root endpoint
+@app.get("/")
+async def root():
+    return {
+        "message": "Welcome to PayViya API - Payment Assistant and Card Recommendation Service",
+        "docs": "/docs"
+    }
+
+if __name__ == "__main__":
+    # Print current working directory and sys.path to help with debugging
+    print(f"Current directory: {os.getcwd()}")
+    print(f"Python path: {sys.path}")
+    uvicorn.run("main:app", host="0.0.0.0", port=8001, reload=True) 
\ No newline at end of file
diff --git a/simple_db_test.py b/simple_db_test.py
new file mode 100644
index 0000000..8160f00
--- /dev/null
+++ b/simple_db_test.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python
+"""
+Simple Database Test
+"""
+
+import os
+import sys
+import dotenv
+from sqlalchemy import create_engine, text
+from sqlalchemy.orm import sessionmaker
+
+# Load environment variables
+dotenv.load_dotenv('./venv/.env')
+
+# Get database connection details
+POSTGRES_SERVER = os.getenv("POSTGRES_SERVER", "localhost")
+POSTGRES_PORT = os.getenv("POSTGRES_PORT", "5432")
+POSTGRES_USER = os.getenv("POSTGRES_USER", "ceyhun")
+POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "")
+POSTGRES_DB = os.getenv("POSTGRES_DB", "payviya")
+
+# Print environment settings
+print(f"Database settings:")
+print(f"  Server: {POSTGRES_SERVER}")
+print(f"  Port: {POSTGRES_PORT}")
+print(f"  User: {POSTGRES_USER}")
+print(f"  Database: {POSTGRES_DB}")
+
+# Create database URL
+if POSTGRES_PASSWORD:
+    DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_SERVER}:{POSTGRES_PORT}/{POSTGRES_DB}"
+else:
+    DATABASE_URL = f"postgresql://{POSTGRES_USER}@{POSTGRES_SERVER}:{POSTGRES_PORT}/{POSTGRES_DB}"
+
+print(f"Using database URL: {DATABASE_URL}")
+
+# Test database connection
+try:
+    # Create engine and session
+    engine = create_engine(DATABASE_URL)
+    Session = sessionmaker(bind=engine)
+    session = Session()
+    
+    # Try a simple query
+    result = session.execute(text("SELECT 1 as test"))
+    value = result.scalar()
+    print(f"Database connection successful! Test query result: {value}")
+    
+    # Try to get tables list
+    result = session.execute(text("SELECT tablename FROM pg_tables WHERE schemaname = 'public'"))
+    tables = [row[0] for row in result]
+    print(f"Found {len(tables)} tables:")
+    for table in tables:
+        print(f"  - {table}")
+    
+    session.close()
+except Exception as e:
+    print(f"Error connecting to database: {str(e)}") 
\ No newline at end of file
diff --git a/swagger_test.py b/swagger_test.py
new file mode 100644
index 0000000..872e645
--- /dev/null
+++ b/swagger_test.py
@@ -0,0 +1,26 @@
+from flask import Flask
+
+app = Flask(__name__)
+
+@app.route('/')
+def home():
+    return """
+    <!DOCTYPE html>
+    <html>
+    <head>
+        <title>PayViya API Documentation</title>
+        <style>
+            body { font-family: Arial, sans-serif; margin: 20px; }
+            h1 { color: #333; }
+        </style>
+    </head>
+    <body>
+        <h1>PayViya API Documentation</h1>
+        <p>Welcome to the PayViya API! The API documentation is available.</p>
+        <p>This is a test page to confirm the Flask server is working.</p>
+    </body>
+    </html>
+    """
+
+if __name__ == '__main__':
+    app.run(debug=True, host='0.0.0.0', port=8080) 
\ No newline at end of file
diff --git a/swagger_viewer.py b/swagger_viewer.py
new file mode 100644
index 0000000..6ac96e1
--- /dev/null
+++ b/swagger_viewer.py
@@ -0,0 +1,213 @@
+from flask import Flask, render_template_string, request
+import yaml
+import json
+import os
+import re
+import glob
+
+app = Flask(__name__)
+
+def find_api_specs():
+    """Find all OpenAPI spec files in the project"""
+    specs = []
+    
+    # Try various common paths for OpenAPI specs
+    spec_paths = [
+        'recommendations_api_spec.yaml',
+        'venv/recommendations_api_spec.yaml',
+        'api_spec.yaml',
+        'openapi.yaml',
+        'swagger.yaml',
+        'openapi.json',
+        'swagger.json'
+    ]
+    
+    for path in spec_paths:
+        if os.path.exists(path):
+            try:
+                with open(path, 'r') as file:
+                    if path.endswith('.yaml') or path.endswith('.yml'):
+                        spec = yaml.safe_load(file)
+                    else:
+                        spec = json.load(file)
+                specs.append({
+                    'name': os.path.basename(path),
+                    'spec': spec
+                })
+            except Exception as e:
+                print(f"Error loading {path}: {e}")
+    
+    return specs
+
+def find_api_endpoints():
+    """Scan the codebase for API endpoints"""
+    endpoints = []
+    
+    # Directories to search
+    dirs_to_search = [
+        'venv/app',
+        'app',
+        'venv/mobile_app',
+        'mobile_app'
+    ]
+    
+    # Look for FastAPI route definitions
+    route_patterns = [
+        r'@(?:app|router|api_router)\.(?:get|post|put|delete|patch)\s*\(\s*[\'"]([^\'"]+)[\'"]',
+        r'\.include_router\([^,]+,\s*prefix=[\'"]([^\'"]+)[\'"]'
+    ]
+    
+    for directory in dirs_to_search:
+        if not os.path.exists(directory):
+            continue
+            
+        # Find Python files
+        for py_file in glob.glob(f"{directory}/**/*.py", recursive=True):
+            try:
+                with open(py_file, 'r') as file:
+                    content = file.read()
+                    
+                for pattern in route_patterns:
+                    for match in re.finditer(pattern, content):
+                        path = match.group(1)
+                        if path.startswith('/'):
+                            endpoints.append({
+                                'path': path,
+                                'file': os.path.relpath(py_file),
+                            })
+                        elif 'prefix=' in pattern:  # This is a router inclusion
+                            # Look for actual routes in this file
+                            router_routes = re.findall(r'@router\.(?:get|post|put|delete|patch)\s*\(\s*[\'"]([^\'"]+)[\'"]', content)
+                            for route in router_routes:
+                                full_path = path + route
+                                endpoints.append({
+                                    'path': full_path,
+                                    'file': os.path.relpath(py_file),
+                                })
+            except Exception as e:
+                print(f"Error processing {py_file}: {e}")
+    
+    return endpoints
+
+@app.route('/')
+def index():
+    """List all available API specs and discovered endpoints"""
+    specs = find_api_specs()
+    endpoints = find_api_endpoints()
+    
+    html = """
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <title>PayViya API Documentation</title>
+        <style>
+            body { font-family: Arial, sans-serif; margin: 20px; }
+            h1, h2 { color: #333; }
+            .section { margin-bottom: 30px; }
+            ul { list-style-type: none; padding: 0; }
+            li { margin: 10px 0; }
+            a { color: #0066cc; text-decoration: none; padding: 10px; background: #f0f0f0; 
+                border-radius: 4px; display: inline-block; }
+            a:hover { background: #e0e0e0; }
+            .endpoint { font-family: monospace; padding: 10px; background: #f8f8f8; border-left: 4px solid #0066cc; margin: 5px 0; }
+            .file-path { color: #666; font-size: 0.8em; margin-left: 10px; }
+        </style>
+    </head>
+    <body>
+        <h1>PayViya API Documentation</h1>
+        
+        <div class="section">
+            <h2>OpenAPI Specifications</h2>
+            {% if specs %}
+            <ul>
+                {% for spec in specs %}
+                <li><a href="/swagger-ui?spec={{ spec.name }}">{{ spec.name }}</a></li>
+                {% endfor %}
+            </ul>
+            {% else %}
+            <p>No API specifications found.</p>
+            {% endif %}
+        </div>
+        
+        <div class="section">
+            <h2>Discovered API Endpoints</h2>
+            {% if endpoints %}
+            <div>
+                {% for endpoint in endpoints %}
+                <div class="endpoint">
+                    {{ endpoint.path }} <span class="file-path">({{ endpoint.file }})</span>
+                </div>
+                {% endfor %}
+            </div>
+            {% else %}
+            <p>No additional API endpoints discovered in the codebase.</p>
+            {% endif %}
+        </div>
+    </body>
+    </html>
+    """
+    
+    return render_template_string(html, specs=specs, endpoints=endpoints)
+
+@app.route('/swagger-ui')
+def swagger_ui():
+    """Display Swagger UI for the selected spec"""
+    spec_name = request.args.get('spec', 'recommendations_api_spec.yaml')
+    
+    specs = find_api_specs()
+    selected_spec = None
+    
+    for spec in specs:
+        if spec['name'] == spec_name:
+            selected_spec = spec['spec']
+            break
+    
+    if not selected_spec:
+        return "API specification not found", 404
+    
+    # Convert to JSON for the Swagger UI
+    api_spec_json = json.dumps(selected_spec)
+    
+    # HTML template with Swagger UI
+    html = """
+    <!DOCTYPE html>
+    <html lang="en">
+    <head>
+        <meta charset="UTF-8">
+        <title>Swagger UI - {{ spec_name }}</title>
+        <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@3/swagger-ui.css">
+        <style>
+            .topbar { display: none; }
+            body { margin: 0; }
+            .back-link { padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ddd; }
+            .back-link a { color: #0066cc; text-decoration: none; }
+        </style>
+    </head>
+    <body>
+        <div class="back-link">
+            <a href="/">← Back to API list</a>
+            <span style="margin-left: 20px; font-weight: bold;">{{ spec_name }}</span>
+        </div>
+        <div id="swagger-ui"></div>
+        <script src="https://unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js"></script>
+        <script>
+            const ui = SwaggerUIBundle({
+                spec: {{ api_spec_json|safe }},
+                dom_id: '#swagger-ui',
+                presets: [
+                    SwaggerUIBundle.presets.apis,
+                    SwaggerUIBundle.SwaggerUIStandalonePreset
+                ],
+                layout: "BaseLayout",
+                deepLinking: true
+            });
+        </script>
+    </body>
+    </html>
+    """
+    
+    return render_template_string(html, api_spec_json=api_spec_json, spec_name=spec_name)
+
+if __name__ == '__main__':
+    app.run(debug=True, port=8080) 
\ No newline at end of file
diff --git a/test_campaign_columns.py b/test_campaign_columns.py
new file mode 100644
index 0000000..13d1105
--- /dev/null
+++ b/test_campaign_columns.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python
+"""
+Campaign Management Columns Test
+"""
+
+import os
+import sys
+import dotenv
+from sqlalchemy import create_engine, text, MetaData, Table, inspect
+from sqlalchemy.orm import sessionmaker
+
+# Load environment variables
+dotenv.load_dotenv('./venv/.env')
+
+# Get database connection details
+POSTGRES_SERVER = os.getenv("POSTGRES_SERVER", "localhost")
+POSTGRES_PORT = os.getenv("POSTGRES_PORT", "5432")
+POSTGRES_USER = os.getenv("POSTGRES_USER", "ceyhun")
+POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "")
+POSTGRES_DB = os.getenv("POSTGRES_DB", "payviya")
+
+# Create database URL
+if POSTGRES_PASSWORD:
+    DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_SERVER}:{POSTGRES_PORT}/{POSTGRES_DB}"
+else:
+    DATABASE_URL = f"postgresql://{POSTGRES_USER}@{POSTGRES_SERVER}:{POSTGRES_PORT}/{POSTGRES_DB}"
+
+print(f"Using database URL: {DATABASE_URL}")
+
+# Connect to database
+try:
+    engine = create_engine(DATABASE_URL)
+    Session = sessionmaker(bind=engine)
+    session = Session()
+    
+    # Get inspector to check table columns
+    inspector = inspect(engine)
+    
+    # Check campaigns table
+    print("\n=== Checking campaigns table columns ===")
+    campaign_columns = inspector.get_columns("campaigns")
+    column_names = [col["name"] for col in campaign_columns]
+    print(f"Found {len(column_names)} columns in campaigns table:")
+    for col in column_names:
+        print(f"  - {col}")
+    
+    # Check for hybrid campaign management columns
+    hybrid_columns = [
+        "source", "status", "external_id", "priority",
+        "last_sync_at", "review_notes", "reviewed_by"
+    ]
+    
+    print("\nChecking for hybrid campaign management columns:")
+    for col in hybrid_columns:
+        if col in column_names:
+            print(f"  ✅ {col} - Found")
+        else:
+            print(f"  ❌ {col} - Missing")
+    
+    # Check banks table
+    print("\n=== Checking banks table columns ===")
+    bank_columns = inspector.get_columns("banks")
+    bank_column_names = [col["name"] for col in bank_columns]
+    print(f"Found {len(bank_column_names)} columns in banks table:")
+    for col in bank_column_names:
+        print(f"  - {col}")
+    
+    # Check for bank sync columns
+    bank_sync_columns = [
+        "campaign_sync_enabled", "campaign_sync_endpoint",
+        "last_campaign_sync_at", "auto_approve_campaigns"
+    ]
+    
+    print("\nChecking for bank sync columns:")
+    for col in bank_sync_columns:
+        if col in bank_column_names:
+            print(f"  ✅ {col} - Found")
+        else:
+            print(f"  ❌ {col} - Missing")
+    
+    # Try to select data from campaigns with the new columns
+    try:
+        print("\n=== Sample campaign data ===")
+        result = session.execute(text("""
+            SELECT id, name, source, status, priority 
+            FROM campaigns
+            LIMIT 3
+        """))
+        
+        # Fixed row handling
+        for row in result:
+            print(f"  Campaign ID: {row.id}, Name: {row.name}")
+            print(f"   - Source: {row.source}")
+            print(f"   - Status: {row.status}")
+            print(f"   - Priority: {row.priority}")
+            print("")
+    except Exception as e:
+        print(f"Error querying campaign data: {str(e)}")
+    
+    session.close()
+    print("\n=== Test Complete ===")
+    
+except Exception as e:
+    print(f"Error: {str(e)}") 
\ No newline at end of file
